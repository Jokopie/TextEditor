"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hocuspocus";
exports.ids = ["vendor-chunks/@hocuspocus"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionTimeout: () => (/* binding */ ConnectionTimeout),\n/* harmony export */   Forbidden: () => (/* binding */ Forbidden),\n/* harmony export */   MessageTooBig: () => (/* binding */ MessageTooBig),\n/* harmony export */   ResetConnection: () => (/* binding */ ResetConnection),\n/* harmony export */   Unauthorized: () => (/* binding */ Unauthorized),\n/* harmony export */   WsReadyStates: () => (/* binding */ WsReadyStates),\n/* harmony export */   awarenessStatesToArray: () => (/* binding */ awarenessStatesToArray),\n/* harmony export */   readAuthMessage: () => (/* binding */ readAuthMessage),\n/* harmony export */   writeAuthenticated: () => (/* binding */ writeAuthenticated),\n/* harmony export */   writeAuthentication: () => (/* binding */ writeAuthentication),\n/* harmony export */   writePermissionDenied: () => (/* binding */ writePermissionDenied)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\nconst BIT8 = 128;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nconst errorUnexpectedEndOfArray = create('Unexpected end of array');\nconst errorIntegerOutOfRange = create('Integer out of Range');\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\nvar AuthMessageType;\n(function (AuthMessageType) {\n    AuthMessageType[AuthMessageType[\"Token\"] = 0] = \"Token\";\n    AuthMessageType[AuthMessageType[\"PermissionDenied\"] = 1] = \"PermissionDenied\";\n    AuthMessageType[AuthMessageType[\"Authenticated\"] = 2] = \"Authenticated\";\n})(AuthMessageType || (AuthMessageType = {}));\nconst writeAuthentication = (encoder, auth) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n    writeVarString(encoder, auth);\n};\nconst writePermissionDenied = (encoder, reason) => {\n    writeVarUint(encoder, AuthMessageType.PermissionDenied);\n    writeVarString(encoder, reason);\n};\nconst writeAuthenticated = (encoder, scope) => {\n    writeVarUint(encoder, AuthMessageType.Authenticated);\n    writeVarString(encoder, scope);\n};\nconst readAuthMessage = (decoder, permissionDeniedHandler, authenticatedHandler) => {\n    switch (readVarUint(decoder)) {\n        case AuthMessageType.PermissionDenied: {\n            permissionDeniedHandler(readVarString(decoder));\n            break;\n        }\n        case AuthMessageType.Authenticated: {\n            authenticatedHandler(readVarString(decoder));\n            break;\n        }\n    }\n};\n\n/**\n * The server is terminating the connection because a data frame was received\n * that is too large.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n */\nconst MessageTooBig = {\n    code: 1009,\n    reason: 'Message Too Big',\n};\n/**\n * The server successfully processed the request, asks that the requester reset\n * its document view, and is not returning any content.\n */\nconst ResetConnection = {\n    code: 4205,\n    reason: 'Reset Connection',\n};\n/**\n * Similar to Forbidden, but specifically for use when authentication is required and has\n * failed or has not yet been provided.\n */\nconst Unauthorized = {\n    code: 4401,\n    reason: 'Unauthorized',\n};\n/**\n * The request contained valid data and was understood by the server, but the server\n * is refusing action.\n */\nconst Forbidden = {\n    code: 4403,\n    reason: 'Forbidden',\n};\n/**\n * The server timed out waiting for the request.\n */\nconst ConnectionTimeout = {\n    code: 4408,\n    reason: 'Connection Timeout',\n};\n\nconst awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n        return {\n            clientId: key,\n            ...value,\n        };\n    });\n};\n\n/**\n * State of the WebSocket connection.\n * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState\n */\nvar WsReadyStates;\n(function (WsReadyStates) {\n    WsReadyStates[WsReadyStates[\"Connecting\"] = 0] = \"Connecting\";\n    WsReadyStates[WsReadyStates[\"Open\"] = 1] = \"Open\";\n    WsReadyStates[WsReadyStates[\"Closing\"] = 2] = \"Closing\";\n    WsReadyStates[WsReadyStates[\"Closed\"] = 3] = \"Closed\";\n})(WsReadyStates || (WsReadyStates = {}));\n\n\n//# sourceMappingURL=hocuspocus-common.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvY29tbW9uL2Rpc3QvaG9jdXNwb2N1cy1jb21tb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhOztBQUVoRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGLDhCQUE4Qjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7O0FBRXVLO0FBQzlNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGV4dC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvY29tbW9uL2Rpc3QvaG9jdXNwb2N1cy1jb21tb24uZXNtLmpzPzJlODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVRTNyA9IDEyNztcblxuLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCBudW1iZXJzLlxuICpcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufTtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGw7XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5sZXQgdXRmOFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSwgaWdub3JlQk9NOiB0cnVlIH0pO1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZW5jb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2VuY29kaW5nXSB3aXRoIFtsaWIwL2RlY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGVuY29kaW5nXG4gKi9cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpO1xuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpO1xuICAgIGVuY29kZXIuY3BvcyA9IDA7XG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bTtcbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggdW5zaWduZWQgaW50ZWdlci4gTWF4IGVuY29kYWJsZSBpbnRlZ2VyIGlzIDJeNTMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgd2hpbGUgKG51bSA+IEJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgQklUOCB8IChCSVRTNyAmIG51bSkpO1xuICAgIG51bSA9IGZsb29yKG51bSAvIDEyOCk7IC8vIHNoaWZ0ID4+PiA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgQklUUzcgJiBudW0pO1xufTtcblxuLyoqXG4gKiBBIGNhY2hlIHRvIHN0b3JlIHN0cmluZ3MgdGVtcG9yYXJpbHlcbiAqL1xuY29uc3QgX3N0ckJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMwMDAwKTtcbmNvbnN0IF9tYXhTdHJCU2l6ZSA9IF9zdHJCdWZmZXIubGVuZ3RoIC8gMztcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IF93cml0ZVZhclN0cmluZ05hdGl2ZSA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPCBfbWF4U3RyQlNpemUpIHtcbiAgICAvLyBXZSBjYW4gZW5jb2RlIHRoZSBzdHJpbmcgaW50byB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB3cml0dGVuID0gdXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyLCBfc3RyQnVmZmVyKS53cml0dGVuIHx8IDA7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHdyaXR0ZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdHRlbjsgaSsrKSB7XG4gICAgICB3cml0ZShlbmNvZGVyLCBfc3RyQnVmZmVyW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGVuY29kZVV0Zjgoc3RyKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbCA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAodXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqLyAodXRmOFRleHRFbmNvZGVyKS5lbmNvZGVJbnRvKSA/IF93cml0ZVZhclN0cmluZ05hdGl2ZSA6IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsO1xuXG4vKipcbiAqIEFwcGVuZCBmaXhlZC1sZW5ndGggVWludDhBcnJheSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGNvbnN0IGNwb3MgPSBlbmNvZGVyLmNwb3M7XG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWluKGJ1ZmZlckxlbiAtIGNwb3MsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgY29uc3QgcmlnaHRDb3B5TGVuID0gdWludDhBcnJheS5sZW5ndGggLSBsZWZ0Q29weUxlbjtcbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3Bvcyk7XG4gIGVuY29kZXIuY3BvcyArPSBsZWZ0Q29weUxlbjtcbiAgaWYgKHJpZ2h0Q29weUxlbiA+IDApIHtcbiAgICAvLyBTdGlsbCBzb21ldGhpbmcgdG8gd3JpdGUsIHdyaXRlIHJpZ2h0IGhhbGYuLlxuICAgIC8vIEFwcGVuZCBuZXcgYnVmZmVyXG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpO1xuICAgIC8vIGNvcHkgYXJyYXlcbiAgICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkobGVmdENvcHlMZW4pKTtcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW47XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kIGFuIFVpbnQ4QXJyYXkgdG8gRW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY3JlYXRlID0gcyA9PiBuZXcgRXJyb3Iocyk7XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gY3JlYXRlKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpO1xuY29uc3QgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZSA9IGNyZWF0ZSgnSW50ZWdlciBvdXQgb2YgUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pO1xuICBkZWNvZGVyLnBvcyArPSBsZW47XG4gIHJldHVybiB2aWV3XG59O1xuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuY29uc3QgcmVhZFVpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBtdWx0ID0gMTtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0OyAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyODsgLy8gbmV4dCBpdGVyYXRpb24sIHNoaWZ0IDcgXCJtb3JlXCIgdG8gdGhlIGxlZnRcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59O1xuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpOyAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwO1xuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlbjtcbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSk7XG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nTmF0aXZlID0gZGVjb2RlciA9PlxuICAvKiogQHR5cGUgYW55ICovICh1dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCByZWFkVmFyU3RyaW5nID0gdXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsO1xuXG52YXIgQXV0aE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChBdXRoTWVzc2FnZVR5cGUpIHtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiVG9rZW5cIl0gPSAwXSA9IFwiVG9rZW5cIjtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IDFdID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gICAgQXV0aE1lc3NhZ2VUeXBlW0F1dGhNZXNzYWdlVHlwZVtcIkF1dGhlbnRpY2F0ZWRcIl0gPSAyXSA9IFwiQXV0aGVudGljYXRlZFwiO1xufSkoQXV0aE1lc3NhZ2VUeXBlIHx8IChBdXRoTWVzc2FnZVR5cGUgPSB7fSkpO1xuY29uc3Qgd3JpdGVBdXRoZW50aWNhdGlvbiA9IChlbmNvZGVyLCBhdXRoKSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIEF1dGhNZXNzYWdlVHlwZS5Ub2tlbik7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgYXV0aCk7XG59O1xuY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBBdXRoTWVzc2FnZVR5cGUuUGVybWlzc2lvbkRlbmllZCk7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgcmVhc29uKTtcbn07XG5jb25zdCB3cml0ZUF1dGhlbnRpY2F0ZWQgPSAoZW5jb2Rlciwgc2NvcGUpID0+IHtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQpO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHNjb3BlKTtcbn07XG5jb25zdCByZWFkQXV0aE1lc3NhZ2UgPSAoZGVjb2RlciwgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIsIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKSA9PiB7XG4gICAgc3dpdGNoIChyZWFkVmFyVWludChkZWNvZGVyKSkge1xuICAgICAgICBjYXNlIEF1dGhNZXNzYWdlVHlwZS5QZXJtaXNzaW9uRGVuaWVkOiB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcihyZWFkVmFyU3RyaW5nKGRlY29kZXIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQ6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKHJlYWRWYXJTdHJpbmcoZGVjb2RlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBzZXJ2ZXIgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiB0aGF0IGlzIHRvbyBsYXJnZS5cbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQvY29kZVxuICovXG5jb25zdCBNZXNzYWdlVG9vQmlnID0ge1xuICAgIGNvZGU6IDEwMDksXG4gICAgcmVhc29uOiAnTWVzc2FnZSBUb28gQmlnJyxcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCB0aGUgcmVxdWVzdCwgYXNrcyB0aGF0IHRoZSByZXF1ZXN0ZXIgcmVzZXRcbiAqIGl0cyBkb2N1bWVudCB2aWV3LCBhbmQgaXMgbm90IHJldHVybmluZyBhbnkgY29udGVudC5cbiAqL1xuY29uc3QgUmVzZXRDb25uZWN0aW9uID0ge1xuICAgIGNvZGU6IDQyMDUsXG4gICAgcmVhc29uOiAnUmVzZXQgQ29ubmVjdGlvbicsXG59O1xuLyoqXG4gKiBTaW1pbGFyIHRvIEZvcmJpZGRlbiwgYnV0IHNwZWNpZmljYWxseSBmb3IgdXNlIHdoZW4gYXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQgYW5kIGhhc1xuICogZmFpbGVkIG9yIGhhcyBub3QgeWV0IGJlZW4gcHJvdmlkZWQuXG4gKi9cbmNvbnN0IFVuYXV0aG9yaXplZCA9IHtcbiAgICBjb2RlOiA0NDAxLFxuICAgIHJlYXNvbjogJ1VuYXV0aG9yaXplZCcsXG59O1xuLyoqXG4gKiBUaGUgcmVxdWVzdCBjb250YWluZWQgdmFsaWQgZGF0YSBhbmQgd2FzIHVuZGVyc3Rvb2QgYnkgdGhlIHNlcnZlciwgYnV0IHRoZSBzZXJ2ZXJcbiAqIGlzIHJlZnVzaW5nIGFjdGlvbi5cbiAqL1xuY29uc3QgRm9yYmlkZGVuID0ge1xuICAgIGNvZGU6IDQ0MDMsXG4gICAgcmVhc29uOiAnRm9yYmlkZGVuJyxcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgdGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSByZXF1ZXN0LlxuICovXG5jb25zdCBDb25uZWN0aW9uVGltZW91dCA9IHtcbiAgICBjb2RlOiA0NDA4LFxuICAgIHJlYXNvbjogJ0Nvbm5lY3Rpb24gVGltZW91dCcsXG59O1xuXG5jb25zdCBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5ID0gKHN0YXRlcykgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDoga2V5LFxuICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvcmVhZHlTdGF0ZVxuICovXG52YXIgV3NSZWFkeVN0YXRlcztcbihmdW5jdGlvbiAoV3NSZWFkeVN0YXRlcykge1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiQ29ubmVjdGluZ1wiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIk9wZW5cIl0gPSAxXSA9IFwiT3BlblwiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNsb3NpbmdcIl0gPSAyXSA9IFwiQ2xvc2luZ1wiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbn0pKFdzUmVhZHlTdGF0ZXMgfHwgKFdzUmVhZHlTdGF0ZXMgPSB7fSkpO1xuXG5leHBvcnQgeyBDb25uZWN0aW9uVGltZW91dCwgRm9yYmlkZGVuLCBNZXNzYWdlVG9vQmlnLCBSZXNldENvbm5lY3Rpb24sIFVuYXV0aG9yaXplZCwgV3NSZWFkeVN0YXRlcywgYXdhcmVuZXNzU3RhdGVzVG9BcnJheSwgcmVhZEF1dGhNZXNzYWdlLCB3cml0ZUF1dGhlbnRpY2F0ZWQsIHdyaXRlQXV0aGVudGljYXRpb24sIHdyaXRlUGVybWlzc2lvbkRlbmllZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9jdXNwb2N1cy1jb21tb24uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AwarenessError: () => (/* binding */ AwarenessError),\n/* harmony export */   HocuspocusProvider: () => (/* binding */ HocuspocusProvider),\n/* harmony export */   HocuspocusProviderWebsocket: () => (/* binding */ HocuspocusProviderWebsocket),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   TiptapCollabProvider: () => (/* binding */ TiptapCollabProvider),\n/* harmony export */   TiptapCollabProviderWebsocket: () => (/* binding */ TiptapCollabProviderWebsocket),\n/* harmony export */   WebSocketStatus: () => (/* binding */ WebSocketStatus)\n/* harmony export */ });\n/* harmony import */ var _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hocuspocus/common */ \"(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lifeomic/attempt */ \"(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\");\n\n\n\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create$2 = () => new Map();\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template V,K\n * @template {Map<K,V>} MAP\n * @param {MAP} map\n * @param {K} key\n * @param {function():V} createT\n * @return {V}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create$1 = () => new Set();\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase();\n\nconst trimLeftRegex = /^\\s*/g;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, '');\n\nconst fromCamelCaseRegex = /([A-Z])/g;\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`));\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nconst undefinedToNull = v => v === undefined ? null : v;\n\n/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map();\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue);\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill();\nlet usePolyfill = true;\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined' && localStorage) {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nconst varStorage = _localStorage;\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler));\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler));\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = [];\n  for (const key in obj) {\n    results.push(f(obj[key], key));\n  }\n  return results\n};\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length$1 = obj => keys(obj).length;\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (length$1(a) !== length$1(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nconst isOneOf = (value, options) => options.includes(value);\n\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n/* c8 ignore next 2 */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n\n/* c8 ignore next */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode;\n/* c8 ignore next 3 */\ntypeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false;\n\n/**\n * @type {Map<string,string>}\n */\nlet params;\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = create$2();\n      const pargs = process.argv;\n      let currParamName = null;\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i];\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '');\n          }\n          currParamName = parg;\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg);\n            currParamName = null;\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '');\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = create$2(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=');\n          params.set(`--${fromCamelCase(key, '-')}`, value);\n          params.set(`-${fromCamelCase(key, '-')}`, value);\n        }\n      });\n    } else {\n      params = create$2();\n    }\n  }\n  return params\n};\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nconst hasParam = (name) => computeParams().has(name);\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nconst getVariable = (name) =>\n  isNode\n    ? undefinedToNull(process.env[name.toUpperCase()])\n    : undefinedToNull(varStorage.getItem(name));\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nconst hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null;\n\n/* c8 ignore next */\nhasConf('production');\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  isOneOf(process.env.FORCE_COLOR, ['true', '1', '2']);\n\n/* c8 ignore start */\n!hasParam('no-colors') &&\n  (!isNode || process.stdout.isTTY || forceColor) && (\n  !isNode || hasParam('color') || forceColor ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n);\n/* c8 ignore stop */\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BITS6 = 63;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nconst errorUnexpectedEndOfArray = create('Unexpected end of array');\nconst errorIntegerOutOfRange = create('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer);\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += fromCharCode(bytes[i]);\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n};\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s);\n  const bytes = createUint8ArrayFromLen(a.length);\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i);\n  }\n  return bytes\n};\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64');\n  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength)\n};\n\n/* c8 ignore next */\nconst toBase64 = isBrowser ? toBase64Browser : toBase64Node;\n\n/* c8 ignore next */\nconst fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;\n\n/* eslint-env browser */\n\n/**\n * @typedef {Object} Channel\n * @property {Set<function(any, any):any>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map();\n\n/* c8 ignore start */\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room;\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null;\n    /**\n     * @param {any} e\n     */\n    this._onChange = e => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || '') });\n    onChange(this._onChange);\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));\n  }\n\n  close () {\n    offChange(this._onChange);\n  }\n}\n/* c8 ignore stop */\n\n// Use BroadcastChannel or Polyfill\n/* c8 ignore next */\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel;\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  setIfUndefined(channels, room, () => {\n    const subs = create$1();\n    const bc = new BC(room);\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    /* c8 ignore next */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data, 'broadcastchannel'));\n    return {\n      bc, subs\n    }\n  });\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nconst subscribe = (room, f) => {\n  getChannel(room).subs.add(f);\n  return f\n};\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nconst unsubscribe = (room, f) => {\n  const channel = getChannel(room);\n  const unsubscribed = channel.subs.delete(f);\n  if (unsubscribed && channel.subs.size === 0) {\n    channel.bc.close();\n    channels.delete(room);\n  }\n  return unsubscribed\n};\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n * @param {any} [origin]\n */\nconst publish = (room, data, origin = null) => {\n  const c = getChannel(room);\n  c.bc.postMessage(data);\n  c.subs.forEach(sub => sub(data, origin));\n};\n\n/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nconst createMutex = () => {\n  let token = true;\n  return (f, g) => {\n    if (token) {\n      token = false;\n      try {\n        f();\n      } finally {\n        token = true;\n      }\n    } else if (g !== undefined) {\n      g();\n    }\n  }\n};\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = create$2();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    setIfUndefined(this._observers, name, create$1).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return from((this._observers.get(name) || create$2()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = create$2();\n  }\n}\n/* c8 ignore end */\n\n/**\n * @module awareness-protocol\n */\n\nconst outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super();\n    this.doc = doc;\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map();\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = getUnixTime();\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, floor(outdatedTimeout / 10)));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n\n  destroy () {\n    this.emit('destroy', [this]);\n    this.setLocalState(null);\n    super.destroy();\n    clearInterval(this._checkInterval);\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n    const prevState = this.states.get(clientID);\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    if (state === null) {\n      removed.push(clientID);\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID);\n      }\n    } else {\n      updated.push(clientID);\n      if (!equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID);\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local']);\n    }\n    this.emit('update', [{ added, updated, removed }, 'local']);\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState();\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      });\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID));\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin]);\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = createEncoder();\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock;\n    writeVarUint(encoder, clientID);\n    writeVarUint(encoder, clock);\n    writeVarString(encoder, JSON.stringify(state));\n  }\n  return toUint8Array(encoder)\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = createDecoder(update);\n  const timestamp = getUnixTime();\n  const added = [];\n  const updated = [];\n  const filteredUpdated = [];\n  const removed = [];\n  const len = readVarUint(decoder);\n  for (let i = 0; i < len; i++) {\n    const clientID = readVarUint(decoder);\n    let clock = readVarUint(decoder);\n    const state = JSON.parse(readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const prevState = awareness.states.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin]);\n  }\n};\n\nclass EventEmitter {\n    constructor() {\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach(callback => callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\n/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nconst encodeQueryParams = params =>\n  map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&');\n\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"Sync\"] = 0] = \"Sync\";\n    MessageType[MessageType[\"Awareness\"] = 1] = \"Awareness\";\n    MessageType[MessageType[\"Auth\"] = 2] = \"Auth\";\n    MessageType[MessageType[\"QueryAwareness\"] = 3] = \"QueryAwareness\";\n    MessageType[MessageType[\"Stateless\"] = 5] = \"Stateless\";\n    MessageType[MessageType[\"CLOSE\"] = 7] = \"CLOSE\";\n    MessageType[MessageType[\"SyncStatus\"] = 8] = \"SyncStatus\";\n})(MessageType || (MessageType = {}));\nvar WebSocketStatus;\n(function (WebSocketStatus) {\n    WebSocketStatus[\"Connecting\"] = \"connecting\";\n    WebSocketStatus[\"Connected\"] = \"connected\";\n    WebSocketStatus[\"Disconnected\"] = \"disconnected\";\n})(WebSocketStatus || (WebSocketStatus = {}));\n\nclass IncomingMessage {\n    constructor(data) {\n        this.data = data;\n        this.encoder = createEncoder();\n        this.decoder = createDecoder(new Uint8Array(this.data));\n    }\n    peekVarString() {\n        return peekVarString(this.decoder);\n    }\n    readVarUint() {\n        return readVarUint(this.decoder);\n    }\n    readVarString() {\n        return readVarString(this.decoder);\n    }\n    readVarUint8Array() {\n        return readVarUint8Array(this.decoder);\n    }\n    writeVarUint(type) {\n        return writeVarUint(this.encoder, type);\n    }\n    writeVarString(string) {\n        return writeVarString(this.encoder, string);\n    }\n    writeVarUint8Array(data) {\n        return writeVarUint8Array(this.encoder, data);\n    }\n    length() {\n        return length(this.encoder);\n    }\n}\n\nclass HocuspocusProviderWebsocket extends EventEmitter {\n    constructor(configuration) {\n        super();\n        this.messageQueue = [];\n        this.configuration = {\n            url: '',\n            // @ts-ignore\n            document: undefined,\n            WebSocketPolyfill: undefined,\n            parameters: {},\n            connect: true,\n            broadcast: true,\n            forceSyncInterval: false,\n            // TODO: this should depend on awareness.outdatedTime\n            messageReconnectTimeout: 30000,\n            // 1 second\n            delay: 1000,\n            // instant\n            initialDelay: 0,\n            // double the delay each time\n            factor: 2,\n            // unlimited retries\n            maxAttempts: 0,\n            // wait at least 1 second\n            minDelay: 1000,\n            // at least every 30 seconds\n            maxDelay: 30000,\n            // randomize\n            jitter: true,\n            // retry forever\n            timeout: 0,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            quiet: false,\n            providerMap: new Map(),\n        };\n        this.webSocket = null;\n        this.webSocketHandlers = {};\n        this.shouldConnect = true;\n        this.status = WebSocketStatus.Disconnected;\n        this.lastMessageReceived = 0;\n        this.identifier = 0;\n        this.intervals = {\n            forceSync: null,\n            connectionChecker: null,\n        };\n        this.connectionAttempt = null;\n        this.receivedOnOpenPayload = undefined;\n        this.receivedOnStatusPayload = undefined;\n        this.closeTries = 0;\n        this.setConfiguration(configuration);\n        this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill\n            ? configuration.WebSocketPolyfill\n            : WebSocket;\n        this.on('open', this.configuration.onOpen);\n        this.on('open', this.onOpen.bind(this));\n        this.on('connect', this.configuration.onConnect);\n        this.on('message', this.configuration.onMessage);\n        this.on('outgoingMessage', this.configuration.onOutgoingMessage);\n        this.on('status', this.configuration.onStatus);\n        this.on('status', this.onStatus.bind(this));\n        this.on('disconnect', this.configuration.onDisconnect);\n        this.on('close', this.configuration.onClose);\n        this.on('destroy', this.configuration.onDestroy);\n        this.on('awarenessUpdate', this.configuration.onAwarenessUpdate);\n        this.on('awarenessChange', this.configuration.onAwarenessChange);\n        this.on('close', this.onClose.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);\n        if (typeof configuration.connect !== 'undefined') {\n            this.shouldConnect = configuration.connect;\n        }\n        if (!this.shouldConnect) {\n            return;\n        }\n        this.connect();\n    }\n    async onOpen(event) {\n        this.receivedOnOpenPayload = event;\n    }\n    async onStatus(data) {\n        this.receivedOnStatusPayload = data;\n    }\n    attach(provider) {\n        let connectPromise;\n        this.configuration.providerMap.set(provider.configuration.name, provider);\n        if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n            connectPromise = this.connect();\n        }\n        if (this.receivedOnOpenPayload) {\n            provider.onOpen(this.receivedOnOpenPayload);\n        }\n        if (this.receivedOnStatusPayload) {\n            provider.onStatus(this.receivedOnStatusPayload);\n        }\n        return connectPromise;\n    }\n    detach(provider) {\n        this.configuration.providerMap.delete(provider.configuration.name);\n    }\n    setConfiguration(configuration = {}) {\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    async connect() {\n        if (this.status === WebSocketStatus.Connected) {\n            return;\n        }\n        // Always cancel any previously initiated connection retryer instances\n        if (this.cancelWebsocketRetry) {\n            this.cancelWebsocketRetry();\n            this.cancelWebsocketRetry = undefined;\n        }\n        this.receivedOnOpenPayload = undefined;\n        this.receivedOnStatusPayload = undefined;\n        this.shouldConnect = true;\n        const abortableRetry = () => {\n            let cancelAttempt = false;\n            const retryPromise = (0,_lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__.retry)(this.createWebSocketConnection.bind(this), {\n                delay: this.configuration.delay,\n                initialDelay: this.configuration.initialDelay,\n                factor: this.configuration.factor,\n                maxAttempts: this.configuration.maxAttempts,\n                minDelay: this.configuration.minDelay,\n                maxDelay: this.configuration.maxDelay,\n                jitter: this.configuration.jitter,\n                timeout: this.configuration.timeout,\n                beforeAttempt: context => {\n                    if (!this.shouldConnect || cancelAttempt) {\n                        context.abort();\n                    }\n                },\n            }).catch((error) => {\n                // If we aborted the connection attempt then dont throw an error\n                // ref: https://github.com/lifeomic/attempt/blob/master/src/index.ts#L136\n                if (error && error.code !== 'ATTEMPT_ABORTED') {\n                    throw error;\n                }\n            });\n            return {\n                retryPromise,\n                cancelFunc: () => {\n                    cancelAttempt = true;\n                },\n            };\n        };\n        const { retryPromise, cancelFunc } = abortableRetry();\n        this.cancelWebsocketRetry = cancelFunc;\n        return retryPromise;\n    }\n    attachWebSocketListeners(ws, reject) {\n        const { identifier } = ws;\n        const onMessageHandler = (payload) => this.emit('message', payload);\n        const onCloseHandler = (payload) => this.emit('close', { event: payload });\n        const onOpenHandler = (payload) => this.emit('open', payload);\n        const onErrorHandler = (err) => {\n            reject(err);\n        };\n        this.webSocketHandlers[identifier] = {\n            message: onMessageHandler,\n            close: onCloseHandler,\n            open: onOpenHandler,\n            error: onErrorHandler,\n        };\n        const handlers = this.webSocketHandlers[ws.identifier];\n        Object.keys(handlers).forEach(name => {\n            ws.addEventListener(name, handlers[name]);\n        });\n    }\n    cleanupWebSocket() {\n        if (!this.webSocket) {\n            return;\n        }\n        const { identifier } = this.webSocket;\n        const handlers = this.webSocketHandlers[identifier];\n        Object.keys(handlers).forEach(name => {\n            var _a;\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers[name]);\n            delete this.webSocketHandlers[identifier];\n        });\n        this.webSocket.close();\n        this.webSocket = null;\n    }\n    createWebSocketConnection() {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                this.messageQueue = [];\n                this.cleanupWebSocket();\n            }\n            this.lastMessageReceived = 0;\n            this.identifier += 1;\n            // Init the WebSocket connection\n            const ws = new this.configuration.WebSocketPolyfill(this.url);\n            ws.binaryType = 'arraybuffer';\n            ws.identifier = this.identifier;\n            this.attachWebSocketListeners(ws, reject);\n            this.webSocket = ws;\n            // Reset the status\n            this.status = WebSocketStatus.Connecting;\n            this.emit('status', { status: WebSocketStatus.Connecting });\n            // Store resolve/reject for later use\n            this.connectionAttempt = {\n                resolve,\n                reject,\n            };\n        });\n    }\n    onMessage(event) {\n        var _a;\n        this.resolveConnectionAttempt();\n        this.lastMessageReceived = getUnixTime();\n        const message = new IncomingMessage(event.data);\n        const documentName = message.peekVarString();\n        (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);\n    }\n    resolveConnectionAttempt() {\n        if (this.connectionAttempt) {\n            this.connectionAttempt.resolve();\n            this.connectionAttempt = null;\n            this.status = WebSocketStatus.Connected;\n            this.emit('status', { status: WebSocketStatus.Connected });\n            this.emit('connect');\n            this.messageQueue.forEach(message => this.send(message));\n            this.messageQueue = [];\n        }\n    }\n    stopConnectionAttempt() {\n        this.connectionAttempt = null;\n    }\n    rejectConnectionAttempt() {\n        var _a;\n        (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();\n        this.connectionAttempt = null;\n    }\n    checkConnection() {\n        var _a;\n        // Dont check the connection when its not even established\n        if (this.status !== WebSocketStatus.Connected) {\n            return;\n        }\n        // Dont close the connection while waiting for the first message\n        if (!this.lastMessageReceived) {\n            return;\n        }\n        // Dont close the connection when a message was received recently\n        if (this.configuration.messageReconnectTimeout\n            >= getUnixTime() - this.lastMessageReceived) {\n            return;\n        }\n        // No message received in a long time, not even your own\n        // Awareness updates, which are updated every 15 seconds\n        // if awareness is enabled.\n        this.closeTries += 1;\n        // https://bugs.webkit.org/show_bug.cgi?id=247943\n        if (this.closeTries > 2) {\n            this.onClose({\n                event: {\n                    code: 4408,\n                    reason: 'forced',\n                },\n            });\n            this.closeTries = 0;\n        }\n        else {\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();\n            this.messageQueue = [];\n        }\n    }\n    // Ensure that the URL always ends with /\n    get serverUrl() {\n        while (this.configuration.url[this.configuration.url.length - 1] === '/') {\n            return this.configuration.url.slice(0, this.configuration.url.length - 1);\n        }\n        return this.configuration.url;\n    }\n    get url() {\n        const encodedParams = encodeQueryParams(this.configuration.parameters);\n        return `${this.serverUrl}${encodedParams.length === 0 ? '' : `?${encodedParams}`}`;\n    }\n    disconnect() {\n        this.shouldConnect = false;\n        if (this.webSocket === null) {\n            return;\n        }\n        try {\n            this.webSocket.close();\n            this.messageQueue = [];\n        }\n        catch {\n            //\n        }\n    }\n    send(message) {\n        var _a;\n        if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.WsReadyStates.Open) {\n            this.webSocket.send(message);\n        }\n        else {\n            this.messageQueue.push(message);\n        }\n    }\n    onClose({ event }) {\n        this.closeTries = 0;\n        this.cleanupWebSocket();\n        if (this.status === WebSocketStatus.Connected) {\n            this.status = WebSocketStatus.Disconnected;\n            this.emit('status', { status: WebSocketStatus.Disconnected });\n            this.emit('disconnect', { event });\n        }\n        if (event.code === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.Unauthorized.code) {\n            if (event.reason === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.Unauthorized.reason) {\n                console.warn('[HocuspocusProvider] An authentication token is required, but you didnt send one. Try adding a `token` to your HocuspocusProvider configuration. Wont try again.');\n            }\n            else {\n                console.warn(`[HocuspocusProvider] Connection closed with status Unauthorized: ${event.reason}`);\n            }\n            this.shouldConnect = false;\n        }\n        if (event.code === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.Forbidden.code) {\n            if (!this.configuration.quiet) {\n                console.warn('[HocuspocusProvider] The provided authentication token isnt allowed to connect to this server. Will try again.');\n                return; // TODO REMOVE ME\n            }\n        }\n        if (event.code === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.MessageTooBig.code) {\n            console.warn(`[HocuspocusProvider] Connection closed with status MessageTooBig: ${event.reason}`);\n            this.shouldConnect = false;\n        }\n        if (this.connectionAttempt) {\n            // That connection attempt failed.\n            this.rejectConnectionAttempt();\n        }\n        else if (this.shouldConnect) {\n            // The connection was closed by the server. Lets just try again.\n            this.connect();\n        }\n        // If well reconnect, were done for now.\n        if (this.shouldConnect) {\n            return;\n        }\n        // The status is set correctly already.\n        if (this.status === WebSocketStatus.Disconnected) {\n            return;\n        }\n        // Lets update the connection status.\n        this.status = WebSocketStatus.Disconnected;\n        this.emit('status', { status: WebSocketStatus.Disconnected });\n        this.emit('disconnect', { event });\n    }\n    destroy() {\n        this.emit('destroy');\n        if (this.intervals.forceSync) {\n            clearInterval(this.intervals.forceSync);\n        }\n        clearInterval(this.intervals.connectionChecker);\n        // If there is still a connection attempt outstanding then we should stop\n        // it before calling disconnect, otherwise it will be rejected in the onClose\n        // handler and trigger a retry\n        this.stopConnectionAttempt();\n        this.disconnect();\n        this.removeAllListeners();\n        this.cleanupWebSocket();\n    }\n}\n\n/**\n * @module sync-protocol\n */\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n *  YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n *  YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0;\nconst messageYjsSyncStep2 = 1;\nconst messageYjsUpdate = 2;\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateVector(doc);\n  writeVarUint8Array(encoder, sv);\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  writeVarUint(encoder, messageYjsSyncStep2);\n  writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateAsUpdate(doc, encodedStateVector));\n};\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, readVarUint8Array(decoder));\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_2__.applyUpdate(doc, readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  writeVarUint(encoder, messageYjsUpdate);\n  writeVarUint8Array(encoder, update);\n};\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2;\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = readVarUint(decoder);\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n};\n\nclass OutgoingMessage {\n    constructor() {\n        this.encoder = createEncoder();\n    }\n    get(args) {\n        return args.encoder;\n    }\n    toUint8Array() {\n        return toUint8Array(this.encoder);\n    }\n}\n\nclass MessageReceiver {\n    constructor(message) {\n        this.broadcasted = false;\n        this.message = message;\n    }\n    setBroadcasted(value) {\n        this.broadcasted = value;\n        return this;\n    }\n    apply(provider, emitSynced) {\n        const { message } = this;\n        const type = message.readVarUint();\n        const emptyMessageLength = message.length();\n        switch (type) {\n            case MessageType.Sync:\n                this.applySyncMessage(provider, emitSynced);\n                break;\n            case MessageType.Awareness:\n                this.applyAwarenessMessage(provider);\n                break;\n            case MessageType.Auth:\n                this.applyAuthMessage(provider);\n                break;\n            case MessageType.QueryAwareness:\n                this.applyQueryAwarenessMessage(provider);\n                break;\n            case MessageType.Stateless:\n                provider.receiveStateless(readVarString(message.decoder));\n                break;\n            case MessageType.SyncStatus:\n                this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1);\n                break;\n            default:\n                throw new Error(`Cant apply message of unknown type: ${type}`);\n        }\n        // Reply\n        if (message.length() > emptyMessageLength + 1) { // length of documentName (considered in emptyMessageLength plus length of yjs sync type, set in applySyncMessage)\n            if (this.broadcasted) {\n                // TODO: Some weird TypeScript error\n                // @ts-ignore\n                provider.broadcast(OutgoingMessage, { encoder: message.encoder });\n            }\n            else {\n                // TODO: Some weird TypeScript error\n                // @ts-ignore\n                provider.send(OutgoingMessage, { encoder: message.encoder });\n            }\n        }\n    }\n    applySyncMessage(provider, emitSynced) {\n        const { message } = this;\n        message.writeVarUint(MessageType.Sync);\n        // Apply update\n        const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);\n        // Synced once we receive Step2\n        if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n            provider.synced = true;\n        }\n    }\n    applySyncStatusMessage(provider, applied) {\n        if (applied) {\n            provider.decrementUnsyncedChanges();\n        }\n    }\n    applyAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        applyAwarenessUpdate(provider.awareness, message.readVarUint8Array(), provider);\n    }\n    applyAuthMessage(provider) {\n        const { message } = this;\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.readAuthMessage)(message.decoder, provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));\n    }\n    applyQueryAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        message.writeVarUint(MessageType.Awareness);\n        message.writeVarUint8Array(encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n    }\n}\n\nclass MessageSender {\n    constructor(Message, args = {}) {\n        this.message = new Message();\n        this.encoder = this.message.get(args);\n    }\n    create() {\n        return toUint8Array(this.encoder);\n    }\n    send(webSocket) {\n        webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());\n    }\n    broadcast(channel) {\n        publish(channel, this.create());\n    }\n}\n\nclass AuthenticationMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Auth;\n        this.description = 'Authentication';\n    }\n    get(args) {\n        if (typeof args.token === 'undefined') {\n            throw new Error('The authentication message requires `token` as an argument.');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.writeAuthentication)(this.encoder, args.token);\n        return this.encoder;\n    }\n}\n\nclass AwarenessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Awareness;\n        this.description = 'Awareness states update';\n    }\n    get(args) {\n        if (typeof args.awareness === 'undefined') {\n            throw new Error('The awareness message requires awareness as an argument');\n        }\n        if (typeof args.clients === 'undefined') {\n            throw new Error('The awareness message requires clients as an argument');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        let awarenessUpdate;\n        if (args.states === undefined) {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients);\n        }\n        else {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states);\n        }\n        writeVarUint8Array(this.encoder, awarenessUpdate);\n        return this.encoder;\n    }\n}\n\nclass CloseMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.CLOSE;\n        this.description = 'Ask the server to close the connection';\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        return this.encoder;\n    }\n}\n\nclass QueryAwarenessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.QueryAwareness;\n        this.description = 'Queries awareness states';\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        return this.encoder;\n    }\n}\n\nclass StatelessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Stateless;\n        this.description = 'A stateless message';\n    }\n    get(args) {\n        var _a;\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeVarString(this.encoder, (_a = args.payload) !== null && _a !== void 0 ? _a : '');\n        return this.encoder;\n    }\n}\n\nclass SyncStepOneMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = 'First sync step';\n    }\n    get(args) {\n        if (typeof args.document === 'undefined') {\n            throw new Error('The sync step one message requires document as an argument');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeSyncStep1(this.encoder, args.document);\n        return this.encoder;\n    }\n}\n\nclass SyncStepTwoMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = 'Second sync step';\n    }\n    get(args) {\n        if (typeof args.document === 'undefined') {\n            throw new Error('The sync step two message requires document as an argument');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeSyncStep2(this.encoder, args.document);\n        return this.encoder;\n    }\n}\n\nclass UpdateMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = 'A document update';\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeUpdate(this.encoder, args.update);\n        return this.encoder;\n    }\n}\n\nclass AwarenessError extends Error {\n    constructor() {\n        super(...arguments);\n        this.code = 1001;\n    }\n}\nclass HocuspocusProvider extends EventEmitter {\n    constructor(configuration) {\n        var _a, _b, _c;\n        super();\n        this.configuration = {\n            name: '',\n            // @ts-ignore\n            document: undefined,\n            // @ts-ignore\n            awareness: undefined,\n            token: null,\n            parameters: {},\n            broadcast: true,\n            forceSyncInterval: false,\n            onAuthenticated: () => null,\n            onAuthenticationFailed: () => null,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onStatus: () => null,\n            onSynced: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            onStateless: () => null,\n            quiet: false,\n            connect: true,\n            preserveConnection: true,\n        };\n        this.subscribedToBroadcastChannel = false;\n        this.isSynced = false;\n        this.unsyncedChanges = 0;\n        this.status = WebSocketStatus.Disconnected;\n        this.isAuthenticated = false;\n        this.authorizedScope = undefined;\n        this.mux = createMutex();\n        this.intervals = {\n            forceSync: null,\n        };\n        this.isConnected = true;\n        this.boundBroadcastChannelSubscriber = this.broadcastChannelSubscriber.bind(this);\n        this.boundPageUnload = this.pageUnload.bind(this);\n        this.boundOnOpen = this.onOpen.bind(this);\n        this.boundOnClose = this.onClose.bind(this);\n        this.boundOnStatus = this.onStatus.bind(this);\n        this.forwardConnect = (e) => this.emit('connect', e);\n        this.forwardOpen = (e) => this.emit('open', e);\n        this.forwardClose = (e) => this.emit('close', e);\n        this.forwardDisconnect = (e) => this.emit('disconnect', e);\n        this.forwardDestroy = (e) => this.emit('destroy', e);\n        this.setConfiguration(configuration);\n        this.configuration.document = configuration.document ? configuration.document : new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n        this.configuration.awareness = configuration.awareness !== undefined ? configuration.awareness : new Awareness(this.document);\n        this.on('open', this.configuration.onOpen);\n        this.on('message', this.configuration.onMessage);\n        this.on('outgoingMessage', this.configuration.onOutgoingMessage);\n        this.on('synced', this.configuration.onSynced);\n        this.on('destroy', this.configuration.onDestroy);\n        this.on('awarenessUpdate', this.configuration.onAwarenessUpdate);\n        this.on('awarenessChange', this.configuration.onAwarenessChange);\n        this.on('stateless', this.configuration.onStateless);\n        this.on('authenticated', this.configuration.onAuthenticated);\n        this.on('authenticationFailed', this.configuration.onAuthenticationFailed);\n        this.configuration.websocketProvider.on('connect', this.configuration.onConnect);\n        this.configuration.websocketProvider.on('connect', this.forwardConnect);\n        this.configuration.websocketProvider.on('open', this.boundOnOpen);\n        this.configuration.websocketProvider.on('open', this.forwardOpen);\n        this.configuration.websocketProvider.on('close', this.boundOnClose);\n        this.configuration.websocketProvider.on('close', this.configuration.onClose);\n        this.configuration.websocketProvider.on('close', this.forwardClose);\n        this.configuration.websocketProvider.on('status', this.boundOnStatus);\n        this.configuration.websocketProvider.on('disconnect', this.configuration.onDisconnect);\n        this.configuration.websocketProvider.on('disconnect', this.forwardDisconnect);\n        this.configuration.websocketProvider.on('destroy', this.configuration.onDestroy);\n        this.configuration.websocketProvider.on('destroy', this.forwardDestroy);\n        (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on('update', () => {\n            this.emit('awarenessUpdate', { states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()) });\n        });\n        (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on('change', () => {\n            this.emit('awarenessChange', { states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()) });\n        });\n        this.document.on('update', this.documentUpdateHandler.bind(this));\n        (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on('update', this.awarenessUpdateHandler.bind(this));\n        this.registerEventListeners();\n        if (this.configuration.forceSyncInterval\n            && typeof this.configuration.forceSyncInterval === 'number') {\n            this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);\n        }\n        this.configuration.websocketProvider.attach(this);\n    }\n    onStatus({ status }) {\n        this.status = status;\n        this.configuration.onStatus({ status });\n        this.emit('status', { status });\n    }\n    setConfiguration(configuration = {}) {\n        if (!configuration.websocketProvider && configuration.url) {\n            const websocketProviderConfig = configuration;\n            this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n                url: websocketProviderConfig.url,\n                connect: websocketProviderConfig.connect,\n                parameters: websocketProviderConfig.parameters,\n            });\n        }\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    get document() {\n        return this.configuration.document;\n    }\n    get awareness() {\n        return this.configuration.awareness;\n    }\n    get hasUnsyncedChanges() {\n        return this.unsyncedChanges > 0;\n    }\n    incrementUnsyncedChanges() {\n        this.unsyncedChanges += 1;\n        this.emit('unsyncedChanges', this.unsyncedChanges);\n    }\n    decrementUnsyncedChanges() {\n        this.unsyncedChanges -= 1;\n        if (this.unsyncedChanges === 0) {\n            this.synced = true;\n        }\n        this.emit('unsyncedChanges', this.unsyncedChanges);\n    }\n    forceSync() {\n        this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });\n    }\n    pageUnload() {\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], 'window unload');\n        }\n    }\n    registerEventListeners() {\n        if (typeof window === 'undefined' || !('addEventListener' in window)) {\n            return;\n        }\n        window.addEventListener('unload', this.boundPageUnload);\n    }\n    sendStateless(payload) {\n        this.send(StatelessMessage, { documentName: this.configuration.name, payload });\n    }\n    documentUpdateHandler(update, origin) {\n        if (origin === this) {\n            return;\n        }\n        this.incrementUnsyncedChanges();\n        this.send(UpdateMessage, { update, documentName: this.configuration.name }, true);\n    }\n    awarenessUpdateHandler({ added, updated, removed }, origin) {\n        const changedClients = added.concat(updated).concat(removed);\n        this.send(AwarenessMessage, {\n            awareness: this.awareness,\n            clients: changedClients,\n            documentName: this.configuration.name,\n        }, true);\n    }\n    /**\n     * Indicates whether a first handshake with the server has been established\n     *\n     * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n     * use `hasUnsyncedChanges`.\n     */\n    get synced() {\n        return this.isSynced;\n    }\n    set synced(state) {\n        if (this.isSynced === state) {\n            return;\n        }\n        this.isSynced = state;\n        this.emit('synced', { state });\n        this.emit('sync', { state });\n    }\n    receiveStateless(payload) {\n        this.emit('stateless', { payload });\n    }\n    get isAuthenticationRequired() {\n        return !!this.configuration.token && !this.isAuthenticated;\n    }\n    // not needed, but provides backward compatibility with e.g. lexicla/yjs\n    async connect() {\n        if (this.configuration.broadcast) {\n            this.subscribeToBroadcastChannel();\n        }\n        this.configuration.websocketProvider.shouldConnect = true;\n        return this.configuration.websocketProvider.attach(this);\n    }\n    disconnect() {\n        this.disconnectBroadcastChannel();\n        this.configuration.websocketProvider.detach(this);\n        this.isConnected = false;\n        if (!this.configuration.preserveConnection) {\n            this.configuration.websocketProvider.disconnect();\n        }\n    }\n    async onOpen(event) {\n        this.isAuthenticated = false;\n        this.isConnected = true;\n        this.emit('open', { event });\n        let token;\n        try {\n            token = await this.getToken();\n        }\n        catch (error) {\n            this.permissionDeniedHandler(`Failed to get token: ${error}`);\n            return;\n        }\n        if (this.isAuthenticationRequired) {\n            this.send(AuthenticationMessage, {\n                token,\n                documentName: this.configuration.name,\n            });\n        }\n        this.startSync();\n    }\n    async getToken() {\n        if (typeof this.configuration.token === 'function') {\n            const token = await this.configuration.token();\n            return token;\n        }\n        return this.configuration.token;\n    }\n    startSync() {\n        this.incrementUnsyncedChanges();\n        this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });\n        if (this.awareness && this.awareness.getLocalState() !== null) {\n            this.send(AwarenessMessage, {\n                awareness: this.awareness,\n                clients: [this.document.clientID],\n                documentName: this.configuration.name,\n            });\n        }\n    }\n    send(message, args, broadcast = false) {\n        if (!this.isConnected) {\n            return;\n        }\n        if (broadcast) {\n            this.mux(() => { this.broadcast(message, args); });\n        }\n        const messageSender = new MessageSender(message, args);\n        this.emit('outgoingMessage', { message: messageSender.message });\n        messageSender.send(this.configuration.websocketProvider);\n    }\n    onMessage(event) {\n        const message = new IncomingMessage(event.data);\n        const documentName = message.readVarString();\n        message.writeVarString(documentName);\n        this.emit('message', { event, message: new IncomingMessage(event.data) });\n        new MessageReceiver(message).apply(this, true);\n    }\n    onClose(event) {\n        this.isAuthenticated = false;\n        this.synced = false;\n        // update awareness (all users except local left)\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter(client => client !== this.document.clientID), this);\n        }\n    }\n    destroy() {\n        this.emit('destroy');\n        if (this.intervals.forceSync) {\n            clearInterval(this.intervals.forceSync);\n        }\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], 'provider destroy');\n            this.awareness.off('update', this.awarenessUpdateHandler);\n            this.awareness.destroy();\n        }\n        this.document.off('update', this.documentUpdateHandler);\n        this.removeAllListeners();\n        this.configuration.websocketProvider.off('connect', this.configuration.onConnect);\n        this.configuration.websocketProvider.off('connect', this.forwardConnect);\n        this.configuration.websocketProvider.off('open', this.boundOnOpen);\n        this.configuration.websocketProvider.off('open', this.forwardOpen);\n        this.configuration.websocketProvider.off('close', this.boundOnClose);\n        this.configuration.websocketProvider.off('close', this.configuration.onClose);\n        this.configuration.websocketProvider.off('close', this.forwardClose);\n        this.configuration.websocketProvider.off('status', this.boundOnStatus);\n        this.configuration.websocketProvider.off('disconnect', this.configuration.onDisconnect);\n        this.configuration.websocketProvider.off('disconnect', this.forwardDisconnect);\n        this.configuration.websocketProvider.off('destroy', this.configuration.onDestroy);\n        this.configuration.websocketProvider.off('destroy', this.forwardDestroy);\n        this.send(CloseMessage, { documentName: this.configuration.name });\n        this.disconnect();\n        if (typeof window === 'undefined' || !('removeEventListener' in window)) {\n            return;\n        }\n        window.removeEventListener('unload', this.boundPageUnload);\n    }\n    permissionDeniedHandler(reason) {\n        this.emit('authenticationFailed', { reason });\n        this.isAuthenticated = false;\n        this.disconnect();\n        this.status = WebSocketStatus.Disconnected;\n    }\n    authenticatedHandler(scope) {\n        this.isAuthenticated = true;\n        this.authorizedScope = scope;\n        this.emit('authenticated');\n    }\n    get broadcastChannel() {\n        return `${this.configuration.name}`;\n    }\n    broadcastChannelSubscriber(data) {\n        this.mux(() => {\n            const message = new IncomingMessage(data);\n            const documentName = message.readVarString();\n            message.writeVarString(documentName);\n            new MessageReceiver(message)\n                .setBroadcasted(true)\n                .apply(this, false);\n        });\n    }\n    subscribeToBroadcastChannel() {\n        if (!this.subscribedToBroadcastChannel) {\n            subscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber);\n            this.subscribedToBroadcastChannel = true;\n        }\n        this.mux(() => {\n            this.broadcast(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });\n            this.broadcast(SyncStepTwoMessage, { document: this.document, documentName: this.configuration.name });\n            this.broadcast(QueryAwarenessMessage, { document: this.document, documentName: this.configuration.name });\n            if (this.awareness) {\n                this.broadcast(AwarenessMessage, {\n                    awareness: this.awareness,\n                    clients: [this.document.clientID],\n                    document: this.document,\n                    documentName: this.configuration.name,\n                });\n            }\n        });\n    }\n    disconnectBroadcastChannel() {\n        // broadcast message with local awareness state set to null (indicating disconnect)\n        if (this.awareness) {\n            this.send(AwarenessMessage, {\n                awareness: this.awareness,\n                clients: [this.document.clientID],\n                states: new Map(),\n                documentName: this.configuration.name,\n            }, true);\n        }\n        if (this.subscribedToBroadcastChannel) {\n            unsubscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber);\n            this.subscribedToBroadcastChannel = false;\n        }\n    }\n    broadcast(Message, args) {\n        if (!this.configuration.broadcast) {\n            return;\n        }\n        if (!this.subscribedToBroadcastChannel) {\n            return;\n        }\n        new MessageSender(Message, args).broadcast(this.broadcastChannel);\n    }\n    setAwarenessField(key, value) {\n        if (!this.awareness) {\n            throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);\n        }\n        this.awareness.setLocalStateField(key, value);\n    }\n}\n\n/* eslint-env browser */\nconst getRandomValues = crypto.getRandomValues.bind(crypto);\n\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\nconst uint32 = () => getRandomValues(new Uint32Array(1))[0];\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;\n\n/**\n * @return {string}\n */\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n);\n\nclass TiptapCollabProviderWebsocket extends HocuspocusProviderWebsocket {\n    constructor(configuration) {\n        var _a;\n        super({ ...configuration, url: (_a = configuration.baseUrl) !== null && _a !== void 0 ? _a : `wss://${configuration.appId}.collab.tiptap.cloud` });\n    }\n}\n\nclass TiptapCollabProvider extends HocuspocusProvider {\n    constructor(configuration) {\n        if (!configuration.websocketProvider) {\n            configuration.websocketProvider = new TiptapCollabProviderWebsocket({ appId: configuration.appId, baseUrl: configuration.baseUrl });\n        }\n        if (!configuration.token) {\n            configuration.token = 'notoken'; // need to send a token anyway (which will be ignored)\n        }\n        super(configuration);\n        this.tiptapCollabConfigurationPrefix = '__tiptapcollab__';\n        if (configuration.user) {\n            this.userData = new yjs__WEBPACK_IMPORTED_MODULE_2__.PermanentUserData(this.document, this.document.getMap('__tiptapcollab__users'));\n            this.userData.setUserMapping(this.document, this.document.clientID, configuration.user);\n        }\n    }\n    /**\n     * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n     */\n    createVersion(name) {\n        return this.sendStateless(JSON.stringify({ action: 'version.create', name }));\n    }\n    /**\n     * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n     */\n    revertToVersion(targetVersion) {\n        return this.sendStateless(JSON.stringify({ action: 'document.revert', version: targetVersion }));\n    }\n    /**\n     * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n     *\n     * The server will reply with a stateless message (THistoryVersionPreviewEvent)\n     */\n    previewVersion(targetVersion) {\n        return this.sendStateless(JSON.stringify({ action: 'version.preview', version: targetVersion }));\n    }\n    /**\n     * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n     */\n    getVersions() {\n        return this.configuration.document.getArray(`${this.tiptapCollabConfigurationPrefix}versions`).toArray();\n    }\n    watchVersions(callback) {\n        return this.configuration.document.getArray('__tiptapcollab__versions').observe(callback);\n    }\n    unwatchVersions(callback) {\n        return this.configuration.document.getArray('__tiptapcollab__versions').unobserve(callback);\n    }\n    isAutoVersioning() {\n        return !!this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).get('autoVersioning');\n    }\n    enableAutoVersioning() {\n        return this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).set('autoVersioning', 1);\n    }\n    disableAutoVersioning() {\n        return this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).set('autoVersioning', 0);\n    }\n    getYThreads() {\n        return this.configuration.document.getArray(`${this.tiptapCollabConfigurationPrefix}threads`);\n    }\n    getThreads() {\n        return this.getYThreads().toJSON();\n    }\n    getThreadIndex(id) {\n        let index = null;\n        let i = 0;\n        // eslint-disable-next-line no-restricted-syntax\n        for (const thread of this.getThreads()) {\n            if (thread.id === id) {\n                index = i;\n                break;\n            }\n            i += 1;\n        }\n        return index;\n    }\n    getThread(id) {\n        const index = this.getThreadIndex(id);\n        if (index === null) {\n            return null;\n        }\n        return this.getYThreads().get(index).toJSON();\n    }\n    getYThread(id) {\n        const index = this.getThreadIndex(id);\n        if (index === null) {\n            return null;\n        }\n        return this.getYThreads().get(index);\n    }\n    createThread(data) {\n        let createdThread = {};\n        this.document.transact(() => {\n            const thread = new yjs__WEBPACK_IMPORTED_MODULE_2__.Map();\n            thread.set('id', uuidv4());\n            thread.set('createdAt', (new Date()).toISOString());\n            thread.set('comments', new yjs__WEBPACK_IMPORTED_MODULE_2__.Array());\n            this.getYThreads().push([thread]);\n            createdThread = this.updateThread(String(thread.get('id')), data);\n        });\n        return createdThread;\n    }\n    updateThread(id, data) {\n        let updatedThread = {};\n        this.document.transact(() => {\n            const thread = this.getYThread(id);\n            if (thread === null) {\n                return null;\n            }\n            thread.set('updatedAt', (new Date()).toISOString());\n            if (data.data) {\n                thread.set('data', data.data);\n            }\n            if (data.resolvedAt || data.resolvedAt === null) {\n                thread.set('resolvedAt', data.resolvedAt);\n            }\n            updatedThread = thread.toJSON();\n        });\n        return updatedThread;\n    }\n    deleteThread(id) {\n        const index = this.getThreadIndex(id);\n        if (index === null) {\n            return;\n        }\n        this.getYThreads().delete(index, 1);\n    }\n    getThreadComments(threadId) {\n        var _a, _b;\n        const index = this.getThreadIndex(threadId);\n        if (index === null) {\n            return null;\n        }\n        return (_b = (_a = this.getThread(threadId)) === null || _a === void 0 ? void 0 : _a.comments) !== null && _b !== void 0 ? _b : [];\n    }\n    getThreadComment(threadId, commentId) {\n        var _a, _b;\n        const index = this.getThreadIndex(threadId);\n        if (index === null) {\n            return null;\n        }\n        return (_b = (_a = this.getThread(threadId)) === null || _a === void 0 ? void 0 : _a.comments.find(comment => comment.id === commentId)) !== null && _b !== void 0 ? _b : null;\n    }\n    addComment(threadId, data) {\n        let updatedThread = {};\n        this.document.transact(() => {\n            const thread = this.getYThread(threadId);\n            if (thread === null)\n                return null;\n            const commentMap = new yjs__WEBPACK_IMPORTED_MODULE_2__.Map();\n            commentMap.set('id', uuidv4());\n            commentMap.set('createdAt', (new Date()).toISOString());\n            thread.get('comments').push([commentMap]);\n            this.updateComment(threadId, String(commentMap.get('id')), data);\n            updatedThread = thread.toJSON();\n        });\n        return updatedThread;\n    }\n    updateComment(threadId, commentId, data) {\n        let updatedThread = {};\n        this.document.transact(() => {\n            const thread = this.getYThread(threadId);\n            if (thread === null)\n                return null;\n            let comment = null;\n            // eslint-disable-next-line no-restricted-syntax\n            for (const c of thread.get('comments')) {\n                if (c.get('id') === commentId) {\n                    comment = c;\n                    break;\n                }\n            }\n            if (comment === null)\n                return null;\n            comment.set('updatedAt', (new Date()).toISOString());\n            if (data.data) {\n                comment.set('data', data.data);\n            }\n            if (data.content) {\n                comment.set('content', data.content);\n            }\n            updatedThread = thread.toJSON();\n        });\n        return updatedThread;\n    }\n    deleteComment(threadId, commentId) {\n        const thread = this.getYThread(threadId);\n        if (thread === null)\n            return null;\n        let commentIndex = 0;\n        // eslint-disable-next-line no-restricted-syntax\n        for (const c of thread.get('comments')) {\n            if (c.get('id') === commentId) {\n                break;\n            }\n            commentIndex += 1;\n        }\n        // if the first comment of a thread is deleted we also\n        // delete the thread itself as the source comment is gone\n        if (commentIndex === 0) {\n            this.deleteThread(threadId);\n            return;\n        }\n        if (commentIndex > 0) {\n            thread.get('comments').delete(commentIndex);\n        }\n        return thread.toJSON();\n    }\n    watchThreads(callback) {\n        this.getYThreads().observeDeep(callback);\n    }\n    unwatchThreads(callback) {\n        this.getYThreads().unobserveDeep(callback);\n    }\n}\n\n\n//# sourceMappingURL=hocuspocus-provider.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvcHJvdmlkZXIvZGlzdC9ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlKO0FBQ2hJO0FBQ2lCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEdBQUc7QUFDZCxXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQSwyRkFBMkYsVUFBVSxFQUFFLG1CQUFtQjs7QUFFMUg7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsYUFBYTs7QUFFaEQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxX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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsb0NBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsMEVBQXNCLDhCQUE4QjtBQUN2RyxTQUFTO0FBQ1Q7QUFD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OUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4SjtBQUM5SiIsInNvdXJjZXMiOlsid2VicGFjazovL3RleHQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0Bob2N1c3BvY3VzL3Byb3ZpZGVyL2Rpc3QvaG9jdXNwb2N1cy1wcm92aWRlci5lc20uanM/ZTE0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXc1JlYWR5U3RhdGVzLCBVbmF1dGhvcml6ZWQsIEZvcmJpZGRlbiwgTWVzc2FnZVRvb0JpZywgcmVhZEF1dGhNZXNzYWdlLCB3cml0ZUF1dGhlbnRpY2F0aW9uLCBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5IH0gZnJvbSAnQGhvY3VzcG9jdXMvY29tbW9uJztcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnQGxpZmVvbWljL2F0dGVtcHQnO1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZSQyID0gKCkgPT4gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEdldCBtYXAgcHJvcGVydHkuIENyZWF0ZSBUIGlmIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBhbmQgc2V0IFQgb24gbWFwLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ZW5lcnMgPSBtYXAuc2V0SWZVbmRlZmluZWQoZXZlbnRzLCAnZXZlbnROYW1lJywgc2V0LmNyZWF0ZSlcbiAqIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBWLEtcbiAqIEB0ZW1wbGF0ZSB7TWFwPEssVj59IE1BUFxuICogQHBhcmFtIHtNQVB9IG1hcFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpWfSBjcmVhdGVUXG4gKiBAcmV0dXJuIHtWfVxuICovXG5jb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpO1xuICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKTtcbiAgfVxuICByZXR1cm4gc2V0XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuY29uc3QgY3JlYXRlJDEgPSAoKSA9PiBuZXcgU2V0KCk7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNvbWV0aGluZyBhcnJheS1saWtlIHRvIGFuIGFjdHVhbCBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPnxJdGVyYWJsZTxUPn0gYXJyYXlsaWtlXG4gKiBAcmV0dXJuIHtUfVxuICovXG5jb25zdCBmcm9tID0gQXJyYXkuZnJvbTtcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc3RyaW5ncy5cbiAqXG4gKiBAbW9kdWxlIHN0cmluZ1xuICovXG5cbmNvbnN0IGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9Mb3dlckNhc2UgPSBzID0+IHMudG9Mb3dlckNhc2UoKTtcblxuY29uc3QgdHJpbUxlZnRSZWdleCA9IC9eXFxzKi9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRyaW1MZWZ0ID0gcyA9PiBzLnJlcGxhY2UodHJpbUxlZnRSZWdleCwgJycpO1xuXG5jb25zdCBmcm9tQ2FtZWxDYXNlUmVnZXggPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGZyb21DYW1lbENhc2UgPSAocywgc2VwYXJhdG9yKSA9PiB0cmltTGVmdChzLnJlcGxhY2UoZnJvbUNhbWVsQ2FzZVJlZ2V4LCBtYXRjaCA9PiBgJHtzZXBhcmF0b3J9JHt0b0xvd2VyQ2FzZShtYXRjaCl9YCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufTtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGw7XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5sZXQgdXRmOFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSwgaWdub3JlQk9NOiB0cnVlIH0pO1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIE9mdGVuIHVzZWQgY29uZGl0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvbmRpdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8bnVsbHx1bmRlZmluZWR9IHZcbiAqIEByZXR1cm4ge1R8bnVsbH1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9IHYgPT4gdiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHY7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIElzb21vcnBoaWMgdmFyaWFibGUgc3RvcmFnZS5cbiAqXG4gKiBVc2VzIExvY2FsU3RvcmFnZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsbHMgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZS5cbiAqXG4gKiBAbW9kdWxlIHN0b3JhZ2VcbiAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNsYXNzIFZhclN0b3JhZ2VQb2x5ZmlsbCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZVxuICAgKi9cbiAgc2V0SXRlbSAoa2V5LCBuZXdWYWx1ZSkge1xuICAgIHRoaXMubWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBnZXRJdGVtIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAdHlwZSB7YW55fVxuICovXG5sZXQgX2xvY2FsU3RvcmFnZSA9IG5ldyBWYXJTdG9yYWdlUG9seWZpbGwoKTtcbmxldCB1c2VQb2x5ZmlsbCA9IHRydWU7XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xudHJ5IHtcbiAgLy8gaWYgdGhlIHNhbWUtb3JpZ2luIHJ1bGUgaXMgdmlvbGF0ZWQsIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2UgbWlnaHQgdGhyb3duIGFuIGVycm9yXG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2UpIHtcbiAgICBfbG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuICAgIHVzZVBvbHlmaWxsID0gZmFsc2U7XG4gIH1cbn0gY2F0Y2ggKGUpIHsgfVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsb2NhbFN0b3JhZ2UgaW4gYnJvd3Nlciwgb3IgYSBwb2x5ZmlsbCBpbiBub2RlanNcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlO1xuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZXZlbnQgPT4gey4ufSlgIHRoYXQgZG9lcyBub3RoaW5nIGlmIHRoZSBwb2x5ZmlsbCBpcyBiZWluZyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeyBrZXk6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB9KTogdm9pZH0gZXZlbnRIYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IG9uQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpO1xuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGByZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZXZlbnQgPT4gey4ufSlgIHRoYXQgZG9lcyBub3RoaW5nIGlmIHRoZSBwb2x5ZmlsbCBpcyBiZWluZyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeyBrZXk6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB9KTogdm9pZH0gZXZlbnRIYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IG9mZkNoYW5nZSA9IGV2ZW50SGFuZGxlciA9PiB1c2VQb2x5ZmlsbCB8fCByZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgLyoqIEB0eXBlIHthbnl9ICovIChldmVudEhhbmRsZXIpKTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIEVjbWFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogQHRvZG8gaW1wbGVtZW50IG1hcFRvQXJyYXkgJiBtYXBcbiAqXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuY29uc3QgbWFwID0gKG9iaiwgZikgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdHMucHVzaChmKG9ialtrZXldLCBrZXkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0c1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGxlbmd0aCQxID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGg7XG5cbi8qKlxuICogQ2FsbHMgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcblxuLyoqXG4gKiBDb21tb24gZnVuY3Rpb25zIGFuZCBmdW5jdGlvbiBjYWxsIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1R9IGFcbiAqIEBwYXJhbSB7VH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYjtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbGl0eURlZXAgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcXVhbGl0eVN0cmljdChhLCBiKVxuICB9XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN3aXRjaCAoYS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgY2FzZSBVaW50OEFycmF5OiB7XG4gICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBTZXQ6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYSkge1xuICAgICAgICBpZiAoIWIuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE1hcDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpIHx8ICFlcXVhbGl0eURlZXAoYS5nZXQoa2V5KSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBPYmplY3Q6XG4gICAgICBpZiAobGVuZ3RoJDEoYSkgIT09IGxlbmd0aCQxKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIWhhc1Byb3BlcnR5KGEsIGtleSkgfHwgIWVxdWFsaXR5RGVlcChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIEFycmF5OlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIHtWfSBPUFRTXG4gKlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtBcnJheTxPUFRTPn0gb3B0aW9uc1xuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCBvcHRpb25zKSA9PiBvcHRpb25zLmluY2x1ZGVzKHZhbHVlKTtcblxuLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSB0byB3b3JrIGFjY2VzcyB0aGUgZW52aXJvbm1lbnQgKHF1ZXJ5IHBhcmFtcywgZW52IHZhcmlhYmxlcykuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlICYmIC9ub2RlfGlvXFwuanMvLnRlc3QocHJvY2Vzcy5yZWxlYXNlLm5hbWUpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTm9kZTtcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbnR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gIDogZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsc3RyaW5nPn1cbiAqL1xubGV0IHBhcmFtcztcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBjb21wdXRlUGFyYW1zID0gKCkgPT4ge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwYXJhbXMgPSBjcmVhdGUkMigpO1xuICAgICAgY29uc3QgcGFyZ3MgPSBwcm9jZXNzLmFyZ3Y7XG4gICAgICBsZXQgY3VyclBhcmFtTmFtZSA9IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmcgPSBwYXJnc1tpXTtcbiAgICAgICAgaWYgKHBhcmdbMF0gPT09ICctJykge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyclBhcmFtTmFtZSA9IHBhcmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgcGFyZyk7XG4gICAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpO1xuICAgICAgfVxuICAgICAgLy8gaW4gUmVhY3ROYXRpdmUgZm9yIGV4YW1wbGUgdGhpcyB3b3VsZCBub3QgYmUgdHJ1ZSAodW5sZXNzIGNvbm5lY3RlZCB0byB0aGUgUmVtb3RlIERlYnVnZ2VyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcGFyYW1zID0gY3JlYXRlJDIoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAobG9jYXRpb24uc2VhcmNoIHx8ICc/Jykuc2xpY2UoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChrdikgPT4ge1xuICAgICAgICBpZiAoa3YubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0ga3Yuc3BsaXQoJz0nKTtcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtLSR7ZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpO1xuICAgICAgICAgIHBhcmFtcy5zZXQoYC0ke2Zyb21DYW1lbENhc2Uoa2V5LCAnLScpfWAsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcyA9IGNyZWF0ZSQyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaGFzUGFyYW0gPSAobmFtZSkgPT4gY29tcHV0ZVBhcmFtcygpLmhhcyhuYW1lKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbmNvbnN0IGdldFZhcmlhYmxlID0gKG5hbWUpID0+XG4gIGlzTm9kZVxuICAgID8gdW5kZWZpbmVkVG9OdWxsKHByb2Nlc3MuZW52W25hbWUudG9VcHBlckNhc2UoKV0pXG4gICAgOiB1bmRlZmluZWRUb051bGwodmFyU3RvcmFnZS5nZXRJdGVtKG5hbWUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuY29uc3QgaGFzQ29uZiA9IChuYW1lKSA9PlxuICBoYXNQYXJhbSgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSkgIT09IG51bGw7XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5oYXNDb25mKCdwcm9kdWN0aW9uJyk7XG5cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmNvbnN0IGZvcmNlQ29sb3IgPSBpc05vZGUgJiZcbiAgaXNPbmVPZihwcm9jZXNzLmVudi5GT1JDRV9DT0xPUiwgWyd0cnVlJywgJzEnLCAnMiddKTtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4haGFzUGFyYW0oJ25vLWNvbG9ycycpICYmXG4gICghaXNOb2RlIHx8IHByb2Nlc3Muc3Rkb3V0LmlzVFRZIHx8IGZvcmNlQ29sb3IpICYmIChcbiAgIWlzTm9kZSB8fCBoYXNQYXJhbSgnY29sb3InKSB8fCBmb3JjZUNvbG9yIHx8XG4gICAgZ2V0VmFyaWFibGUoJ0NPTE9SVEVSTScpICE9PSBudWxsIHx8XG4gICAgKGdldFZhcmlhYmxlKCdURVJNJykgfHwgJycpLmluY2x1ZGVzKCdjb2xvcicpXG4pO1xuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbmNvbnN0IEJJVDcgPSA2NDtcbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVRTNiA9IDYzO1xuY29uc3QgQklUUzcgPSAxMjc7XG5cbi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggbnVtYmVycy5cbiAqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cbi8qKlxuICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMDtcbiAgICB0aGlzLmNidWYgPSBuZXcgVWludDhBcnJheSgxMDApO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZnMgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuY29uc3QgY3JlYXRlRW5jb2RlciA9ICgpID0+IG5ldyBFbmNvZGVyKCk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGRhdGEuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgbGVuZ3RoID0gZW5jb2RlciA9PiB7XG4gIGxldCBsZW4gPSBlbmNvZGVyLmNwb3M7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVuICs9IGVuY29kZXIuYnVmc1tpXS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGxlblxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdG8gVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGNyZWF0ZWQgQXJyYXlCdWZmZXIuXG4gKi9cbmNvbnN0IHRvVWludDhBcnJheSA9IGVuY29kZXIgPT4ge1xuICBjb25zdCB1aW50OGFyciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aChlbmNvZGVyKSk7XG4gIGxldCBjdXJQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV07XG4gICAgdWludDhhcnIuc2V0KGQsIGN1clBvcyk7XG4gICAgY3VyUG9zICs9IGQubGVuZ3RoO1xuICB9XG4gIHVpbnQ4YXJyLnNldChuZXcgVWludDhBcnJheShlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpO1xuICByZXR1cm4gdWludDhhcnJcbn07XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW4gKiAyKTtcbiAgICBlbmNvZGVyLmNwb3MgPSAwO1xuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW07XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBCSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIEJJVDggfCAoQklUUzcgJiBudW0pKTtcbiAgICBudW0gPSBmbG9vcihudW0gLyAxMjgpOyAvLyBzaGlmdCA+Pj4gN1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIEJJVFM3ICYgbnVtKTtcbn07XG5cbi8qKlxuICogQSBjYWNoZSB0byBzdG9yZSBzdHJpbmdzIHRlbXBvcmFyaWx5XG4gKi9cbmNvbnN0IF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzMDAwMCk7XG5jb25zdCBfbWF4U3RyQlNpemUgPSBfc3RyQnVmZmVyLmxlbmd0aCAvIDM7XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgLy8gV2UgY2FuIGVuY29kZSB0aGUgc3RyaW5nIGludG8gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3Qgd3JpdHRlbiA9IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGVVdGY4KHN0cikpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3QgX3dyaXRlVmFyU3RyaW5nUG9seWZpbGwgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHdyaXRlVmFyU3RyaW5nID0gKHV0ZjhUZXh0RW5jb2RlciAmJiAvKiogQHR5cGUge2FueX0gKi8gKHV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zO1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1heChidWZmZXJMZW4gKiAyLCByaWdodENvcHlMZW4pKTtcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVZhclVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpO1xufTtcblxuLyoqXG4gKiBFcnJvciBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZXJyb3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpO1xuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGRlY29kaW5nXG4gKi9cblxuY29uc3QgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheSA9IGNyZWF0ZSgnVW5leHBlY3RlZCBlbmQgb2YgYXJyYXknKTtcbmNvbnN0IGVycm9ySW50ZWdlck91dE9mUmFuZ2UgPSBjcmVhdGUoJ0ludGVnZXIgb3V0IG9mIFJhbmdlJyk7XG5cbi8qKlxuICogQSBEZWNvZGVyIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5IEJpbmFyeSBkYXRhIHRvIGRlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGluZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IHVpbnQ4QXJyYXk7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkZWNvZGluZyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0RlY29kZXJ9XG4gKi9cbmNvbnN0IGNyZWF0ZURlY29kZXIgPSB1aW50OEFycmF5ID0+IG5ldyBEZWNvZGVyKHVpbnQ4QXJyYXkpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBVaW50OEFycmF5IHZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMgYW5kIGFkdmFuY2UgdGhlIHBvc2l0aW9uIGJ5IGBsZW5gLlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBUaGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHJlYWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRVaW50OEFycmF5ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbik7XG4gIGRlY29kZXIucG9zICs9IGxlbjtcbiAgcmV0dXJuIHZpZXdcbn07XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRWYXJVaW50OEFycmF5ID0gZGVjb2RlciA9PiByZWFkVWludDhBcnJheShkZWNvZGVyLCByZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBvbmUgYnl0ZSBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge251bWJlcn0gVW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICovXG5jb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5jb25zdCByZWFkVmFyVWludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgbnVtID0gMDtcbiAgbGV0IG11bHQgPSAxO1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGg7XG4gIHdoaWxlIChkZWNvZGVyLnBvcyA8IGxlbikge1xuICAgIGNvbnN0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIEJJVFM3KSAqIG11bHQ7IC8vIHNoaWZ0ICRyIDw8ICg3KiNpdGVyYXRpb25zKSBhbmQgYWRkIGl0IHRvIG51bVxuICAgIG11bHQgKj0gMTI4OyAvLyBuZXh0IGl0ZXJhdGlvbiwgc2hpZnQgNyBcIm1vcmVcIiB0byB0aGUgbGVmdFxuICAgIGlmIChyIDwgQklUOCkge1xuICAgICAgcmV0dXJuIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICB9XG4gIHRocm93IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXlcbn07XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmNvbnN0IHJlYWRWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgbGV0IG51bSA9IHIgJiBCSVRTNjtcbiAgbGV0IG11bHQgPSA2NDtcbiAgY29uc3Qgc2lnbiA9IChyICYgQklUNykgPiAwID8gLTEgOiAxO1xuICBpZiAoKHIgJiBCSVQ4KSA9PT0gMCkge1xuICAgIC8vIGRvbid0IGNvbnRpbnVlIHJlYWRpbmdcbiAgICByZXR1cm4gc2lnbiAqIG51bVxuICB9XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuICAgIC8vIG51bSA9IG51bSB8ICgociAmIGJpbmFyeS5CSVRTNykgPDwgbGVuKVxuICAgIG51bSA9IG51bSArIChyICYgQklUUzcpICogbXVsdDtcbiAgICBtdWx0ICo9IDEyODtcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBzaWduICogbnVtXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChudW0gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufTtcblxuLyoqXG4gKiBXZSBkb24ndCB0ZXN0IHRoaXMgZnVuY3Rpb24gYW55bW9yZSBhcyB3ZSB1c2UgbmF0aXZlIGRlY29kaW5nL2VuY29kaW5nIGJ5IGRlZmF1bHQgbm93LlxuICogQmV0dGVyIG5vdCBtb2RpZnkgdGhpcyBhbnltb3JlLi5cbiAqXG4gKiBUcmFuc2Zvcm1pbmcgdXRmOCB0byBhIHN0cmluZyBpcyBwcmV0dHkgZXhwZW5zaXZlLiBUaGUgY29kZSBwZXJmb3JtcyAxMHggYmV0dGVyXG4gKiB3aGVuIFN0cmluZy5mcm9tQ29kZVBvaW50IGlzIGZlZCB3aXRoIGFsbCBjaGFyYWN0ZXJzIGFzIGFyZ3VtZW50cy5cbiAqIEJ1dCBtb3N0IGVudmlyb25tZW50cyBoYXZlIGEgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHBlciBmdW5jdGlvbnMuXG4gKiBGb3IgZWZmaWVuY3kgcmVhc29ucyB3ZSBhcHBseSBhIG1heGltdW0gb2YgMTAwMDAgY2hhcmFjdGVycyBhdCBvbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZy5cbiAqL1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBfcmVhZFZhclN0cmluZ1BvbHlmaWxsID0gZGVjb2RlciA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgaWYgKHJlbWFpbmluZ0xlbiA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIGxldCBlbmNvZGVkU3RyaW5nID0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKTsgLy8gcmVtZW1iZXIgdG8gZGVjcmVhc2UgcmVtYWluaW5nTGVuXG4gICAgaWYgKC0tcmVtYWluaW5nTGVuIDwgMTAwKSB7IC8vIGRvIG5vdCBjcmVhdGUgYSBVaW50OEFycmF5IGZvciBzbWFsbCBzdHJpbmdzXG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuLS0pIHtcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMDtcbiAgICAgICAgLy8gdGhpcyBpcyBkYW5nZXJvdXMsIHdlIGNyZWF0ZSBhIGZyZXNoIGFycmF5IHZpZXcgZnJvbSB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGVjb2Rlci5hcnIuc3ViYXJyYXkoZGVjb2Rlci5wb3MsIGRlY29kZXIucG9zICsgbmV4dExlbik7XG4gICAgICAgIGRlY29kZXIucG9zICs9IG5leHRMZW47XG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChieXRlcykpO1xuICAgICAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG4gIH1cbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICovXG5jb25zdCBfcmVhZFZhclN0cmluZ05hdGl2ZSA9IGRlY29kZXIgPT5cbiAgLyoqIEB0eXBlIGFueSAqLyAodXRmOFRleHREZWNvZGVyKS5kZWNvZGUocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcmVhZFZhclN0cmluZyA9IHV0ZjhUZXh0RGVjb2RlciA/IF9yZWFkVmFyU3RyaW5nTmF0aXZlIDogX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclN0cmluZyB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHBlZWtWYXJTdHJpbmcgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3M7XG4gIGNvbnN0IHMgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICBkZWNvZGVyLnBvcyA9IHBvcztcbiAgcmV0dXJuIHNcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIGJ1ZmZlcnMgKFVpbnQ4QXJyYXkpLlxuICpcbiAqIEBtb2R1bGUgYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuID0gbGVuID0+IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbi8qKlxuICogQ3JlYXRlIFVpbnQ4QXJyYXkgd2l0aCBpbml0aWFsIGNvbnRlbnQgZnJvbSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyID0gKGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSA9PiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG5cbi8qKlxuICogQ3JlYXRlIFVpbnQ4QXJyYXkgd2l0aCBpbml0aWFsIGNvbnRlbnQgZnJvbSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXJcbiAqL1xuY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NEJyb3dzZXIgPSBieXRlcyA9PiB7XG4gIGxldCBzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSBmcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICByZXR1cm4gYnRvYShzKVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBmcm9tQmFzZTY0QnJvd3NlciA9IHMgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY29uc3QgYSA9IGF0b2Iocyk7XG4gIGNvbnN0IGJ5dGVzID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4oYS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXNcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKi9cbmNvbnN0IGZyb21CYXNlNjROb2RlID0gcyA9PiB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsICdiYXNlNjQnKTtcbiAgcmV0dXJuIGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aClcbn07XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCB0b0Jhc2U2NCA9IGlzQnJvd3NlciA/IHRvQmFzZTY0QnJvd3NlciA6IHRvQmFzZTY0Tm9kZTtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGZyb21CYXNlNjQgPSBpc0Jyb3dzZXIgPyBmcm9tQmFzZTY0QnJvd3NlciA6IGZyb21CYXNlNjROb2RlO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDaGFubmVsXG4gKiBAcHJvcGVydHkge1NldDxmdW5jdGlvbihhbnksIGFueSk6YW55Pn0gQ2hhbm5lbC5zdWJzXG4gKiBAcHJvcGVydHkge2FueX0gQ2hhbm5lbC5iY1xuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsIENoYW5uZWw+fVxuICovXG5jb25zdCBjaGFubmVscyA9IG5ldyBNYXAoKTtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb20pIHtcbiAgICB0aGlzLnJvb20gPSByb29tO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsfGZ1bmN0aW9uKHtkYXRhOkFycmF5QnVmZmVyfSk6dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGVcbiAgICAgKi9cbiAgICB0aGlzLl9vbkNoYW5nZSA9IGUgPT4gZS5rZXkgPT09IHJvb20gJiYgdGhpcy5vbm1lc3NhZ2UgIT09IG51bGwgJiYgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBmcm9tQmFzZTY0KGUubmV3VmFsdWUgfHwgJycpIH0pO1xuICAgIG9uQ2hhbmdlKHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZcbiAgICovXG4gIHBvc3RNZXNzYWdlIChidWYpIHtcbiAgICB2YXJTdG9yYWdlLnNldEl0ZW0odGhpcy5yb29tLCB0b0Jhc2U2NChjcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyKGJ1ZikpKTtcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBvZmZDaGFuZ2UodGhpcy5fb25DaGFuZ2UpO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vLyBVc2UgQnJvYWRjYXN0Q2hhbm5lbCBvciBQb2x5ZmlsbFxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IEJDID0gdHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICd1bmRlZmluZWQnID8gTG9jYWxTdG9yYWdlUG9seWZpbGwgOiBCcm9hZGNhc3RDaGFubmVsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcmV0dXJuIHtDaGFubmVsfVxuICovXG5jb25zdCBnZXRDaGFubmVsID0gcm9vbSA9PlxuICBzZXRJZlVuZGVmaW5lZChjaGFubmVscywgcm9vbSwgKCkgPT4ge1xuICAgIGNvbnN0IHN1YnMgPSBjcmVhdGUkMSgpO1xuICAgIGNvbnN0IGJjID0gbmV3IEJDKHJvb20pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e2RhdGE6QXJyYXlCdWZmZXJ9fSBlXG4gICAgICovXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBiYy5vbm1lc3NhZ2UgPSBlID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGUuZGF0YSwgJ2Jyb2FkY2FzdGNoYW5uZWwnKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJjLCBzdWJzXG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGBwdWJsaXNoYCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSk6YW55fSBmXG4gKi9cbmNvbnN0IHN1YnNjcmliZSA9IChyb29tLCBmKSA9PiB7XG4gIGdldENoYW5uZWwocm9vbSkuc3Vicy5hZGQoZik7XG4gIHJldHVybiBmXG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYHB1Ymxpc2hgIGdsb2JhbCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSk6YW55fSBmXG4gKi9cbmNvbnN0IHVuc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IHtcbiAgY29uc3QgY2hhbm5lbCA9IGdldENoYW5uZWwocm9vbSk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlZCA9IGNoYW5uZWwuc3Vicy5kZWxldGUoZik7XG4gIGlmICh1bnN1YnNjcmliZWQgJiYgY2hhbm5lbC5zdWJzLnNpemUgPT09IDApIHtcbiAgICBjaGFubmVsLmJjLmNsb3NlKCk7XG4gICAgY2hhbm5lbHMuZGVsZXRlKHJvb20pO1xuICB9XG4gIHJldHVybiB1bnN1YnNjcmliZWRcbn07XG5cbi8qKlxuICogUHVibGlzaCBkYXRhIHRvIGFsbCBzdWJzY3JpYmVycyAoaW5jbHVkaW5nIHN1YnNjcmliZXJzIG9uIHRoaXMgdGFiKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKiBAcGFyYW0ge2FueX0gW29yaWdpbl1cbiAqL1xuY29uc3QgcHVibGlzaCA9IChyb29tLCBkYXRhLCBvcmlnaW4gPSBudWxsKSA9PiB7XG4gIGNvbnN0IGMgPSBnZXRDaGFubmVsKHJvb20pO1xuICBjLmJjLnBvc3RNZXNzYWdlKGRhdGEpO1xuICBjLnN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGRhdGEsIG9yaWdpbikpO1xufTtcblxuLyoqXG4gKiBNdXR1YWwgZXhjbHVkZSBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11dGV4XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgbXV0ZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYiBPbmx5IGV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBbZWxzZUNiXSBFeGVjdXRlZCB3aGVuIHRoaXMgbXV0ZXggaXMgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG11dGV4ID0gY3JlYXRlTXV0ZXgoKVxuICogbXV0ZXgoKCkgPT4ge1xuICogICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGV4ZWN1dGVkXG4gKiAgIG11dGV4KCgpID0+IHtcbiAqICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYXMgdGhlIG11dGV4IGlzIGFscmVhZHkgYWN0aXZlLlxuICogICB9KVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge211dGV4fSBBIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGNyZWF0ZU11dGV4ID0gKCkgPT4ge1xuICBsZXQgdG9rZW4gPSB0cnVlO1xuICByZXR1cm4gKGYsIGcpID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRva2VuID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBmKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGcoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRpbWUuXG4gKlxuICogQG1vZHVsZSB0aW1lXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB1bml4IHRpbWUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBnZXRVbml4VGltZSA9IERhdGUubm93O1xuXG4vKipcbiAqIE9ic2VydmFibGUgY2xhc3MgcHJvdG90eXBlLlxuICpcbiAqIEBtb2R1bGUgb2JzZXJ2YWJsZVxuICovXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHRlbXBsYXRlIE5cbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSQyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uIChuYW1lLCBmKSB7XG4gICAgc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBjcmVhdGUkMSkuYWRkKGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlIChuYW1lLCBmKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpO1xuICAgICAgZiguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgX2YpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpO1xuICAgIGlmIChvYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKTtcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBjcmVhdGUkMigpKS52YWx1ZXMoKSkuZm9yRWFjaChmID0+IGYoLi4uYXJncykpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUkMigpO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgZW5kICovXG5cbi8qKlxuICogQG1vZHVsZSBhd2FyZW5lc3MtcHJvdG9jb2xcbiAqL1xuXG5jb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50SUQgPSBkb2MuY2xpZW50SUQ7XG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IGdldFVuaXhUaW1lKCk7XG4gICAgICBpZiAodGhpcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgKG91dGRhdGVkVGltZW91dCAvIDIgPD0gbm93IC0gLyoqIEB0eXBlIHt7bGFzdFVwZGF0ZWQ6bnVtYmVyfX0gKi8gKHRoaXMubWV0YS5nZXQodGhpcy5jbGllbnRJRCkpLmxhc3RVcGRhdGVkKSkge1xuICAgICAgICAvLyByZW5ldyBsb2NhbCBjbG9ja1xuICAgICAgICB0aGlzLnNldExvY2FsU3RhdGUodGhpcy5nZXRMb2NhbFN0YXRlKCkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLCByZW1vdmUsICd0aW1lb3V0Jyk7XG4gICAgICB9XG4gICAgfSwgZmxvb3Iob3V0ZGF0ZWRUaW1lb3V0IC8gMTApKSk7XG4gICAgZG9jLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEO1xuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKTtcbiAgICBjb25zdCBjbG9jayA9IGN1cnJMb2NhbE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjdXJyTG9jYWxNZXRhLmNsb2NrICsgMTtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IGdldFVuaXhUaW1lKClcbiAgICB9KTtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXTtcbiAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpO1xuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgaWYgKCFlcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbZmllbGRdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5jb25zdCByZW1vdmVBd2FyZW5lc3NTdGF0ZXMgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV07XG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpO1xuICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQpIHtcbiAgICAgICAgY29uc3QgY3VyTWV0YSA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSk7XG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRCk7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKTtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIGNsaWVudHMsIHN0YXRlcyA9IGF3YXJlbmVzcy5zdGF0ZXMpID0+IHtcbiAgY29uc3QgbGVuID0gY2xpZW50cy5sZW5ndGg7XG4gIGNvbnN0IGVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldO1xuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbDtcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2s7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKTtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gIH1cbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZURlY29kZXIodXBkYXRlKTtcbiAgY29uc3QgdGltZXN0YW1wID0gZ2V0VW5peFRpbWUoKTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXTtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgbGV0IGNsb2NrID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKHJlYWRWYXJTdHJpbmcoZGVjb2RlcikpO1xuICAgIGNvbnN0IGNsaWVudE1ldGEgPSBhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpO1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKTtcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9jaztcbiAgICBpZiAoY3VyckNsb2NrIDwgY2xvY2sgfHwgKGN1cnJDbG9jayA9PT0gY2xvY2sgJiYgc3RhdGUgPT09IG51bGwgJiYgYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSkge1xuICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldmVyIGxldCBhIHJlbW90ZSBjbGllbnQgcmVtb3ZlIHRoaXMgbG9jYWwgc3RhdGVcbiAgICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQgJiYgYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmVtb3RlIGNsaWVudCByZW1vdmVkIHRoZSBsb2NhbCBzdGF0ZS4gRG8gbm90IHJlbW90ZSBzdGF0ZS4gQnJvYWRjYXN0IGEgbWVzc2FnZSBpbmRpY2F0aW5nXG4gICAgICAgICAgLy8gdGhhdCB0aGlzIGNsaWVudCBzdGlsbCBleGlzdHMgYnkgaW5jcmVhc2luZyB0aGUgY2xvY2tcbiAgICAgICAgICBjbG9jaysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICBjbG9jayxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWVzdGFtcFxuICAgICAgfSk7XG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSk7XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKTtcbiAgfVxufTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcihjYWxsYmFjayA9PiBjYWxsYmFjayAhPT0gZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdXJscy5cbiAqXG4gKiBAbW9kdWxlIHVybFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IHBhcmFtc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGVRdWVyeVBhcmFtcyA9IHBhcmFtcyA9PlxuICBtYXAocGFyYW1zLCAodmFsLCBrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWwpfWApLmpvaW4oJyYnKTtcblxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU3luY1wiXSA9IDBdID0gXCJTeW5jXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJBd2FyZW5lc3NcIl0gPSAxXSA9IFwiQXdhcmVuZXNzXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJBdXRoXCJdID0gMl0gPSBcIkF1dGhcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlF1ZXJ5QXdhcmVuZXNzXCJdID0gM10gPSBcIlF1ZXJ5QXdhcmVuZXNzXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTdGF0ZWxlc3NcIl0gPSA1XSA9IFwiU3RhdGVsZXNzXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJDTE9TRVwiXSA9IDddID0gXCJDTE9TRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU3luY1N0YXR1c1wiXSA9IDhdID0gXCJTeW5jU3RhdHVzXCI7XG59KShNZXNzYWdlVHlwZSB8fCAoTWVzc2FnZVR5cGUgPSB7fSkpO1xudmFyIFdlYlNvY2tldFN0YXR1cztcbihmdW5jdGlvbiAoV2ViU29ja2V0U3RhdHVzKSB7XG4gICAgV2ViU29ja2V0U3RhdHVzW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIFdlYlNvY2tldFN0YXR1c1tcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gICAgV2ViU29ja2V0U3RhdHVzW1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbn0pKFdlYlNvY2tldFN0YXR1cyB8fCAoV2ViU29ja2V0U3RhdHVzID0ge30pKTtcblxuY2xhc3MgSW5jb21pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gY3JlYXRlRGVjb2RlcihuZXcgVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgICB9XG4gICAgcGVla1ZhclN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHBlZWtWYXJTdHJpbmcodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclVpbnQoKSB7XG4gICAgICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICByZWFkVmFyU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gcmVhZFZhclN0cmluZyh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICByZWFkVmFyVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRWYXJVaW50OEFycmF5KHRoaXMuZGVjb2Rlcik7XG4gICAgfVxuICAgIHdyaXRlVmFyVWludCh0eXBlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0eXBlKTtcbiAgICB9XG4gICAgd3JpdGVWYXJTdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIHN0cmluZyk7XG4gICAgfVxuICAgIHdyaXRlVmFyVWludDhBcnJheShkYXRhKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5lbmNvZGVyLCBkYXRhKTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHRoaXMuZW5jb2Rlcik7XG4gICAgfVxufVxuXG5jbGFzcyBIb2N1c3BvY3VzUHJvdmlkZXJXZWJzb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRvY3VtZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBXZWJTb2NrZXRQb2x5ZmlsbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgYnJvYWRjYXN0OiB0cnVlLFxuICAgICAgICAgICAgZm9yY2VTeW5jSW50ZXJ2YWw6IGZhbHNlLFxuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgZGVwZW5kIG9uIGF3YXJlbmVzcy5vdXRkYXRlZFRpbWVcbiAgICAgICAgICAgIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgIC8vIDEgc2Vjb25kXG4gICAgICAgICAgICBkZWxheTogMTAwMCxcbiAgICAgICAgICAgIC8vIGluc3RhbnRcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogMCxcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgZGVsYXkgZWFjaCB0aW1lXG4gICAgICAgICAgICBmYWN0b3I6IDIsXG4gICAgICAgICAgICAvLyB1bmxpbWl0ZWQgcmV0cmllc1xuICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICAvLyB3YWl0IGF0IGxlYXN0IDEgc2Vjb25kXG4gICAgICAgICAgICBtaW5EZWxheTogMTAwMCxcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IGV2ZXJ5IDMwIHNlY29uZHNcbiAgICAgICAgICAgIG1heERlbGF5OiAzMDAwMCxcbiAgICAgICAgICAgIC8vIHJhbmRvbWl6ZVxuICAgICAgICAgICAgaml0dGVyOiB0cnVlLFxuICAgICAgICAgICAgLy8gcmV0cnkgZm9yZXZlclxuICAgICAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgICAgIG9uT3BlbjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ29ubmVjdDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uT3V0Z29pbmdNZXNzYWdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TdGF0dXM6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NVcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF3YXJlbmVzc0NoYW5nZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIHF1aWV0OiBmYWxzZSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2ViU29ja2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0ge1xuICAgICAgICAgICAgZm9yY2VTeW5jOiBudWxsLFxuICAgICAgICAgICAgY29ubmVjdGlvbkNoZWNrZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZE9uU3RhdHVzUGF5bG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbG9zZVRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uV2ViU29ja2V0UG9seWZpbGwgPSBjb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsXG4gICAgICAgICAgICA/IGNvbmZpZ3VyYXRpb24uV2ViU29ja2V0UG9seWZpbGxcbiAgICAgICAgICAgIDogV2ViU29ja2V0O1xuICAgICAgICB0aGlzLm9uKCdvcGVuJywgdGhpcy5jb25maWd1cmF0aW9uLm9uT3Blbik7XG4gICAgICAgIHRoaXMub24oJ29wZW4nLCB0aGlzLm9uT3Blbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbignY29ubmVjdCcsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNvbm5lY3QpO1xuICAgICAgICB0aGlzLm9uKCdtZXNzYWdlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMub24oJ291dGdvaW5nTWVzc2FnZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbk91dGdvaW5nTWVzc2FnZSk7XG4gICAgICAgIHRoaXMub24oJ3N0YXR1cycsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXR1cyk7XG4gICAgICAgIHRoaXMub24oJ3N0YXR1cycsIHRoaXMub25TdGF0dXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5vbignY2xvc2UnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25DbG9zZSk7XG4gICAgICAgIHRoaXMub24oJ2Rlc3Ryb3knLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5vbignYXdhcmVuZXNzVXBkYXRlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzVXBkYXRlKTtcbiAgICAgICAgdGhpcy5vbignYXdhcmVuZXNzQ2hhbmdlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5vbignY2xvc2UnLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24oJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMuY29ubmVjdGlvbkNoZWNrZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrQ29ubmVjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZ3VyYXRpb24ubWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAxMCk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5jb25uZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb25uZWN0ID0gY29uZmlndXJhdGlvbi5jb25uZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIG9uT3BlbihldmVudCkge1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCA9IGV2ZW50O1xuICAgIH1cbiAgICBhc3luYyBvblN0YXR1cyhkYXRhKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRPblN0YXR1c1BheWxvYWQgPSBkYXRhO1xuICAgIH1cbiAgICBhdHRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgbGV0IGNvbm5lY3RQcm9taXNlO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZXJNYXAuc2V0KHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ubmFtZSwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgJiYgdGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICBjb25uZWN0UHJvbWlzZSA9IHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCkge1xuICAgICAgICAgICAgcHJvdmlkZXIub25PcGVuKHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNlaXZlZE9uU3RhdHVzUGF5bG9hZCkge1xuICAgICAgICAgICAgcHJvdmlkZXIub25TdGF0dXModGhpcy5yZWNlaXZlZE9uU3RhdHVzUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3RQcm9taXNlO1xuICAgIH1cbiAgICBkZXRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmRlbGV0ZShwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUpO1xuICAgIH1cbiAgICBzZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24gPSB7fSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7IC4uLnRoaXMuY29uZmlndXJhdGlvbiwgLi4uY29uZmlndXJhdGlvbiB9O1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgY2FuY2VsIGFueSBwcmV2aW91c2x5IGluaXRpYXRlZCBjb25uZWN0aW9uIHJldHJ5ZXIgaW5zdGFuY2VzXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25TdGF0dXNQYXlsb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlO1xuICAgICAgICBjb25zdCBhYm9ydGFibGVSZXRyeSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjYW5jZWxBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXRyeVByb21pc2UgPSByZXRyeSh0aGlzLmNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgICAgIGRlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24uZGVsYXksXG4gICAgICAgICAgICAgICAgaW5pdGlhbERlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24uaW5pdGlhbERlbGF5LFxuICAgICAgICAgICAgICAgIGZhY3RvcjogdGhpcy5jb25maWd1cmF0aW9uLmZhY3RvcixcbiAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogdGhpcy5jb25maWd1cmF0aW9uLm1heEF0dGVtcHRzLFxuICAgICAgICAgICAgICAgIG1pbkRlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24ubWluRGVsYXksXG4gICAgICAgICAgICAgICAgbWF4RGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5tYXhEZWxheSxcbiAgICAgICAgICAgICAgICBqaXR0ZXI6IHRoaXMuY29uZmlndXJhdGlvbi5qaXR0ZXIsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWd1cmF0aW9uLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgYmVmb3JlQXR0ZW1wdDogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRDb25uZWN0IHx8IGNhbmNlbEF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhYm9ydGVkIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQgdGhlbiBkb27igJl0IHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vbGlmZW9taWMvYXR0ZW1wdC9ibG9iL21hc3Rlci9zcmMvaW5kZXgudHMjTDEzNlxuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlICE9PSAnQVRURU1QVF9BQk9SVEVEJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmV0cnlQcm9taXNlLFxuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgcmV0cnlQcm9taXNlLCBjYW5jZWxGdW5jIH0gPSBhYm9ydGFibGVSZXRyeSgpO1xuICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gY2FuY2VsRnVuYztcbiAgICAgICAgcmV0dXJuIHJldHJ5UHJvbWlzZTtcbiAgICB9XG4gICAgYXR0YWNoV2ViU29ja2V0TGlzdGVuZXJzKHdzLCByZWplY3QpIHtcbiAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyIH0gPSB3cztcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlSGFuZGxlciA9IChwYXlsb2FkKSA9PiB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZUhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KCdjbG9zZScsIHsgZXZlbnQ6IHBheWxvYWQgfSk7XG4gICAgICAgIGNvbnN0IG9uT3BlbkhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KCdvcGVuJywgcGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3JIYW5kbGVyID0gKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2ViU29ja2V0SGFuZGxlcnNbaWRlbnRpZmllcl0gPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBvbk1lc3NhZ2VIYW5kbGVyLFxuICAgICAgICAgICAgY2xvc2U6IG9uQ2xvc2VIYW5kbGVyLFxuICAgICAgICAgICAgb3Blbjogb25PcGVuSGFuZGxlcixcbiAgICAgICAgICAgIGVycm9yOiBvbkVycm9ySGFuZGxlcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLndlYlNvY2tldEhhbmRsZXJzW3dzLmlkZW50aWZpZXJdO1xuICAgICAgICBPYmplY3Qua2V5cyhoYW5kbGVycykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cFdlYlNvY2tldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gdGhpcy53ZWJTb2NrZXQ7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMud2ViU29ja2V0SGFuZGxlcnNbaWRlbnRpZmllcl07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndlYlNvY2tldC5jbG9zZSgpO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IG51bGw7XG4gICAgfVxuICAgIGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllciArPSAxO1xuICAgICAgICAgICAgLy8gSW5pdCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHdzID0gbmV3IHRoaXMuY29uZmlndXJhdGlvbi5XZWJTb2NrZXRQb2x5ZmlsbCh0aGlzLnVybCk7XG4gICAgICAgICAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHdzLmlkZW50aWZpZXIgPSB0aGlzLmlkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFdlYlNvY2tldExpc3RlbmVycyh3cywgcmVqZWN0KTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0ID0gd3M7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgc3RhdHVzXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0aW5nO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGF0dXMnLCB7IHN0YXR1czogV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RpbmcgfSk7XG4gICAgICAgICAgICAvLyBTdG9yZSByZXNvbHZlL3JlamVjdCBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IGdldFVuaXhUaW1lKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjb25zdCBkb2N1bWVudE5hbWUgPSBtZXNzYWdlLnBlZWtWYXJTdHJpbmcoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmdldChkb2N1bWVudE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25NZXNzYWdlKGV2ZW50KTtcbiAgICB9XG4gICAgcmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdHVzJywgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmZvckVhY2gobWVzc2FnZSA9PiB0aGlzLnNlbmQobWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29ubmVjdGlvbkF0dGVtcHQoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICByZWplY3RDb25uZWN0aW9uQXR0ZW1wdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICBjaGVja0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRG9u4oCZdCBjaGVjayB0aGUgY29ubmVjdGlvbiB3aGVuIGl04oCZcyBub3QgZXZlbiBlc3RhYmxpc2hlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb27igJl0IGNsb3NlIHRoZSBjb25uZWN0aW9uIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCBtZXNzYWdlXG4gICAgICAgIGlmICghdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9u4oCZdCBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIGEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgcmVjZW50bHlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5tZXNzYWdlUmVjb25uZWN0VGltZW91dFxuICAgICAgICAgICAgPj0gZ2V0VW5peFRpbWUoKSAtIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1lc3NhZ2UgcmVjZWl2ZWQgaW4gYSBsb25nIHRpbWUsIG5vdCBldmVuIHlvdXIgb3duXG4gICAgICAgIC8vIEF3YXJlbmVzcyB1cGRhdGVzLCB3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzXG4gICAgICAgIC8vIGlmIGF3YXJlbmVzcyBpcyBlbmFibGVkLlxuICAgICAgICB0aGlzLmNsb3NlVHJpZXMgKz0gMTtcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI0Nzk0M1xuICAgICAgICBpZiAodGhpcy5jbG9zZVRyaWVzID4gMikge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0NDA4LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246ICdmb3JjZWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBVUkwgYWx3YXlzIGVuZHMgd2l0aCAvXG4gICAgZ2V0IHNlcnZlclVybCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29uZmlndXJhdGlvbi51cmxbdGhpcy5jb25maWd1cmF0aW9uLnVybC5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnVybC5zbGljZSgwLCB0aGlzLmNvbmZpZ3VyYXRpb24udXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXJsO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gZW5jb2RlUXVlcnlQYXJhbXModGhpcy5jb25maWd1cmF0aW9uLnBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zZXJ2ZXJVcmx9JHtlbmNvZGVkUGFyYW1zLmxlbmd0aCA9PT0gMCA/ICcnIDogYD8ke2VuY29kZWRQYXJhbXN9YH1gO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSBXc1JlYWR5U3RhdGVzLk9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoeyBldmVudCB9KSB7XG4gICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdHVzJywgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCB7IGV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5jb2RlID09PSBVbmF1dGhvcml6ZWQuY29kZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJlYXNvbiA9PT0gVW5hdXRob3JpemVkLnJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hvY3VzcG9jdXNQcm92aWRlcl0gQW4gYXV0aGVudGljYXRpb24gdG9rZW4gaXMgcmVxdWlyZWQsIGJ1dCB5b3UgZGlkbuKAmXQgc2VuZCBvbmUuIFRyeSBhZGRpbmcgYSBgdG9rZW5gIHRvIHlvdXIgSG9jdXNwb2N1c1Byb3ZpZGVyIGNvbmZpZ3VyYXRpb24uIFdvbuKAmXQgdHJ5IGFnYWluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSG9jdXNwb2N1c1Byb3ZpZGVyXSBDb25uZWN0aW9uIGNsb3NlZCB3aXRoIHN0YXR1cyBVbmF1dGhvcml6ZWQ6ICR7ZXZlbnQucmVhc29ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IEZvcmJpZGRlbi5jb2RlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlndXJhdGlvbi5xdWlldCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hvY3VzcG9jdXNQcm92aWRlcl0gVGhlIHByb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlzbuKAmXQgYWxsb3dlZCB0byBjb25uZWN0IHRvIHRoaXMgc2VydmVyLiBXaWxsIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE8gUkVNT1ZFIE1FXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IE1lc3NhZ2VUb29CaWcuY29kZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSG9jdXNwb2N1c1Byb3ZpZGVyXSBDb25uZWN0aW9uIGNsb3NlZCB3aXRoIHN0YXR1cyBNZXNzYWdlVG9vQmlnOiAke2V2ZW50LnJlYXNvbn1gKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25BdHRlbXB0KSB7XG4gICAgICAgICAgICAvLyBUaGF0IGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlsZWQuXG4gICAgICAgICAgICB0aGlzLnJlamVjdENvbm5lY3Rpb25BdHRlbXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAvLyBUaGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ5IHRoZSBzZXJ2ZXIuIExldOKAmXMganVzdCB0cnkgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZeKAmWxsIHJlY29ubmVjdCwgd2XigJlyZSBkb25lIGZvciBub3cuXG4gICAgICAgIGlmICh0aGlzLnNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc3RhdHVzIGlzIHNldCBjb3JyZWN0bHkgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV04oCZcyB1cGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdHVzJywgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHsgZXZlbnQgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVzdHJveScpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbHMuZm9yY2VTeW5jKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxzLmZvcmNlU3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFscy5jb25uZWN0aW9uQ2hlY2tlcik7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIGEgY29ubmVjdGlvbiBhdHRlbXB0IG91dHN0YW5kaW5nIHRoZW4gd2Ugc2hvdWxkIHN0b3BcbiAgICAgICAgLy8gaXQgYmVmb3JlIGNhbGxpbmcgZGlzY29ubmVjdCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgcmVqZWN0ZWQgaW4gdGhlIG9uQ2xvc2VcbiAgICAgICAgLy8gaGFuZGxlciBhbmQgdHJpZ2dlciBhIHJldHJ5XG4gICAgICAgIHRoaXMuc3RvcENvbm5lY3Rpb25BdHRlbXB0KCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmNsZWFudXBXZWJTb2NrZXQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQG1vZHVsZSBzeW5jLXByb3RvY29sXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiDigKIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiDigKIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWxkIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc3NhcnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwO1xuY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDE7XG5jb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMjtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKTtcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYyk7XG4gIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKTtcbiAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpO1xufTtcblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5jb25zdCByZWFkU3luY1N0ZXAxID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYykgPT5cbiAgd3JpdGVTeW5jU3RlcDIoZW5jb2RlciwgZG9jLCByZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkU3luY1N0ZXAyID0gKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgdHJ5IHtcbiAgICBZLmFwcGx5VXBkYXRlKGRvYywgcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBldmVudCBoYW5kbGVyc1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnJvciB3aGlsZSBoYW5kbGluZyBhIFlqcyB1cGRhdGUnLCBlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5jb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpO1xuICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKTtcbn07XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkVXBkYXRlID0gcmVhZFN5bmNTdGVwMjtcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gRG9lcyBub3QgbmVlZCB0byBiZSBzZW50IGlmIGVtcHR5LlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMTpcbiAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgZG9jKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnKVxuICB9XG4gIHJldHVybiBtZXNzYWdlVHlwZVxufTtcblxuY2xhc3MgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICByZXR1cm4gYXJncy5lbmNvZGVyO1xuICAgIH1cbiAgICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKTtcbiAgICB9XG59XG5cbmNsYXNzIE1lc3NhZ2VSZWNlaXZlciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIHNldEJyb2FkY2FzdGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFwcGx5KHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UucmVhZFZhclVpbnQoKTtcbiAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN5bmM6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXdhcmVuZXNzOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXV0aDpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXV0aE1lc3NhZ2UocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5RdWVyeUF3YXJlbmVzczpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UXVlcnlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3RhdGVsZXNzOlxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlY2VpdmVTdGF0ZWxlc3MocmVhZFZhclN0cmluZyhtZXNzYWdlLmRlY29kZXIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3luY1N0YXR1czpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIHJlYWRWYXJJbnQobWVzc2FnZS5kZWNvZGVyKSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBhcHBseSBtZXNzYWdlIG9mIHVua25vd24gdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGx5XG4gICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCgpID4gZW1wdHlNZXNzYWdlTGVuZ3RoICsgMSkgeyAvLyBsZW5ndGggb2YgZG9jdW1lbnROYW1lIChjb25zaWRlcmVkIGluIGVtcHR5TWVzc2FnZUxlbmd0aCBwbHVzIGxlbmd0aCBvZiB5anMgc3luYyB0eXBlLCBzZXQgaW4gYXBwbHlTeW5jTWVzc2FnZSlcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU29tZSB3ZWlyZCBUeXBlU2NyaXB0IGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmJyb2FkY2FzdChPdXRnb2luZ01lc3NhZ2UsIHsgZW5jb2RlcjogbWVzc2FnZS5lbmNvZGVyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU29tZSB3ZWlyZCBUeXBlU2NyaXB0IGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNlbmQoT3V0Z29pbmdNZXNzYWdlLCB7IGVuY29kZXI6IG1lc3NhZ2UuZW5jb2RlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuU3luYyk7XG4gICAgICAgIC8vIEFwcGx5IHVwZGF0ZVxuICAgICAgICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSByZWFkU3luY01lc3NhZ2UobWVzc2FnZS5kZWNvZGVyLCBtZXNzYWdlLmVuY29kZXIsIHByb3ZpZGVyLmRvY3VtZW50LCBwcm92aWRlcik7XG4gICAgICAgIC8vIFN5bmNlZCBvbmNlIHdlIHJlY2VpdmUgU3RlcDJcbiAgICAgICAgaWYgKGVtaXRTeW5jZWQgJiYgc3luY01lc3NhZ2VUeXBlID09PSBtZXNzYWdlWWpzU3luY1N0ZXAyKSB7XG4gICAgICAgICAgICBwcm92aWRlci5zeW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIGFwcGxpZWQpIHtcbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRlY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyLmF3YXJlbmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSB0aGlzO1xuICAgICAgICBhcHBseUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIG1lc3NhZ2UucmVhZFZhclVpbnQ4QXJyYXkoKSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBhcHBseUF1dGhNZXNzYWdlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgcmVhZEF1dGhNZXNzYWdlKG1lc3NhZ2UuZGVjb2RlciwgcHJvdmlkZXIucGVybWlzc2lvbkRlbmllZEhhbmRsZXIuYmluZChwcm92aWRlciksIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWRIYW5kbGVyLmJpbmQocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXBwbHlRdWVyeUF3YXJlbmVzc01lc3NhZ2UocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlci5hd2FyZW5lc3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuQXdhcmVuZXNzKTtcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgTWVzc2FnZVNlbmRlciB7XG4gICAgY29uc3RydWN0b3IoTWVzc2FnZSwgYXJncyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG5ldyBNZXNzYWdlKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHRoaXMubWVzc2FnZS5nZXQoYXJncyk7XG4gICAgfVxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpO1xuICAgIH1cbiAgICBzZW5kKHdlYlNvY2tldCkge1xuICAgICAgICB3ZWJTb2NrZXQgPT09IG51bGwgfHwgd2ViU29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWJTb2NrZXQuc2VuZCh0aGlzLmNyZWF0ZSgpKTtcbiAgICB9XG4gICAgYnJvYWRjYXN0KGNoYW5uZWwpIHtcbiAgICAgICAgcHVibGlzaChjaGFubmVsLCB0aGlzLmNyZWF0ZSgpKTtcbiAgICB9XG59XG5cbmNsYXNzIEF1dGhlbnRpY2F0aW9uTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLkF1dGg7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXV0aGVudGljYXRpb24nO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MudG9rZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhdXRoZW50aWNhdGlvbiBtZXNzYWdlIHJlcXVpcmVzIGB0b2tlbmAgYXMgYW4gYXJndW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlQXV0aGVudGljYXRpb24odGhpcy5lbmNvZGVyLCBhcmdzLnRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIEF3YXJlbmVzc01lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5Bd2FyZW5lc3M7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXdhcmVuZXNzIHN0YXRlcyB1cGRhdGUnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuYXdhcmVuZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXdhcmVuZXNzIG1lc3NhZ2UgcmVxdWlyZXMgYXdhcmVuZXNzIGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmNsaWVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhd2FyZW5lc3MgbWVzc2FnZSByZXF1aXJlcyBjbGllbnRzIGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIGxldCBhd2FyZW5lc3NVcGRhdGU7XG4gICAgICAgIGlmIChhcmdzLnN0YXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cywgYXJncy5zdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyVWludDhBcnJheSh0aGlzLmVuY29kZXIsIGF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBDbG9zZU1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5DTE9TRTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdBc2sgdGhlIHNlcnZlciB0byBjbG9zZSB0aGUgY29ubmVjdGlvbic7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgUXVlcnlBd2FyZW5lc3NNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuUXVlcnlBd2FyZW5lc3M7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUXVlcmllcyBhd2FyZW5lc3Mgc3RhdGVzJztcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTdGF0ZWxlc3NNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3RhdGVsZXNzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Egc3RhdGVsZXNzIG1lc3NhZ2UnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIChfYSA9IGFyZ3MucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgU3luY1N0ZXBPbmVNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3luYztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdGaXJzdCBzeW5jIHN0ZXAnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzeW5jIHN0ZXAgb25lIG1lc3NhZ2UgcmVxdWlyZXMgZG9jdW1lbnQgYXMgYW4gYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnROYW1lKTtcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdGhpcy50eXBlKTtcbiAgICAgICAgd3JpdGVTeW5jU3RlcDEodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIFN5bmNTdGVwVHdvTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLlN5bmM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnU2Vjb25kIHN5bmMgc3RlcCc7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJncy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN5bmMgc3RlcCB0d28gbWVzc2FnZSByZXF1aXJlcyBkb2N1bWVudCBhcyBhbiBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVN5bmNTdGVwMih0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgVXBkYXRlTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLlN5bmM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQSBkb2N1bWVudCB1cGRhdGUnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnROYW1lKTtcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdGhpcy50eXBlKTtcbiAgICAgICAgd3JpdGVVcGRhdGUodGhpcy5lbmNvZGVyLCBhcmdzLnVwZGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBBd2FyZW5lc3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb2RlID0gMTAwMTtcbiAgICB9XG59XG5jbGFzcyBIb2N1c3BvY3VzUHJvdmlkZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZG9jdW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGF3YXJlbmVzczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgIGJyb2FkY2FzdDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlU3luY0ludGVydmFsOiBmYWxzZSxcbiAgICAgICAgICAgIG9uQXV0aGVudGljYXRlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXV0aGVudGljYXRpb25GYWlsZWQ6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk9wZW46ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk1lc3NhZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk91dGdvaW5nTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdHVzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TeW5jZWQ6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NVcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF3YXJlbmVzc0NoYW5nZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdGVsZXNzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgcXVpZXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNlcnZlQ29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkVG9Ccm9hZGNhc3RDaGFubmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnN5bmNlZENoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aG9yaXplZFNjb3BlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm11eCA9IGNyZWF0ZU11dGV4KCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0ge1xuICAgICAgICAgICAgZm9yY2VTeW5jOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ib3VuZEJyb2FkY2FzdENoYW5uZWxTdWJzY3JpYmVyID0gdGhpcy5icm9hZGNhc3RDaGFubmVsU3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kUGFnZVVubG9hZCA9IHRoaXMucGFnZVVubG9hZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kT25PcGVuID0gdGhpcy5vbk9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZE9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZE9uU3RhdHVzID0gdGhpcy5vblN0YXR1cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZvcndhcmRDb25uZWN0ID0gKGUpID0+IHRoaXMuZW1pdCgnY29ubmVjdCcsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmRPcGVuID0gKGUpID0+IHRoaXMuZW1pdCgnb3BlbicsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmRDbG9zZSA9IChlKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJywgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZERpc2Nvbm5lY3QgPSAoZSkgPT4gdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZERlc3Ryb3kgPSAoZSkgPT4gdGhpcy5lbWl0KCdkZXN0cm95JywgZSk7XG4gICAgICAgIHRoaXMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRvY3VtZW50ID0gY29uZmlndXJhdGlvbi5kb2N1bWVudCA/IGNvbmZpZ3VyYXRpb24uZG9jdW1lbnQgOiBuZXcgWS5Eb2MoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmF3YXJlbmVzcyA9IGNvbmZpZ3VyYXRpb24uYXdhcmVuZXNzICE9PSB1bmRlZmluZWQgPyBjb25maWd1cmF0aW9uLmF3YXJlbmVzcyA6IG5ldyBBd2FyZW5lc3ModGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMub24oJ29wZW4nLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PcGVuKTtcbiAgICAgICAgdGhpcy5vbignbWVzc2FnZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKCdvdXRnb2luZ01lc3NhZ2UnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PdXRnb2luZ01lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKCdzeW5jZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TeW5jZWQpO1xuICAgICAgICB0aGlzLm9uKCdkZXN0cm95JywgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oJ2F3YXJlbmVzc1VwZGF0ZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ2F3YXJlbmVzc0NoYW5nZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc0NoYW5nZSk7XG4gICAgICAgIHRoaXMub24oJ3N0YXRlbGVzcycsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXRlbGVzcyk7XG4gICAgICAgIHRoaXMub24oJ2F1dGhlbnRpY2F0ZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25BdXRoZW50aWNhdGVkKTtcbiAgICAgICAgdGhpcy5vbignYXV0aGVudGljYXRpb25GYWlsZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25BdXRoZW50aWNhdGlvbkZhaWxlZCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignY29ubmVjdCcsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nvbm5lY3QnLCB0aGlzLmZvcndhcmRDb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKCdvcGVuJywgdGhpcy5ib3VuZE9uT3Blbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignb3BlbicsIHRoaXMuZm9yd2FyZE9wZW4pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5mb3J3YXJkQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ3N0YXR1cycsIHRoaXMuYm91bmRPblN0YXR1cyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignZGlzY29ubmVjdCcsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLmZvcndhcmREaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKCdkZXN0cm95JywgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignZGVzdHJveScsIHRoaXMuZm9yd2FyZERlc3Ryb3kpO1xuICAgICAgICAoX2EgPSB0aGlzLmF3YXJlbmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2F3YXJlbmVzc1VwZGF0ZScsIHsgc3RhdGVzOiBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5KHRoaXMuYXdhcmVuZXNzLmdldFN0YXRlcygpKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIChfYiA9IHRoaXMuYXdhcmVuZXNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYXdhcmVuZXNzQ2hhbmdlJywgeyBzdGF0ZXM6IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkodGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbigndXBkYXRlJywgdGhpcy5kb2N1bWVudFVwZGF0ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIChfYyA9IHRoaXMuYXdhcmVuZXNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub24oJ3VwZGF0ZScsIHRoaXMuYXdhcmVuZXNzVXBkYXRlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uZm9yY2VTeW5jSW50ZXJ2YWxcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGlzLmNvbmZpZ3VyYXRpb24uZm9yY2VTeW5jSW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5mb3JjZVN5bmMgPSBzZXRJbnRlcnZhbCh0aGlzLmZvcmNlU3luYy5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZ3VyYXRpb24uZm9yY2VTeW5jSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5hdHRhY2godGhpcyk7XG4gICAgfVxuICAgIG9uU3RhdHVzKHsgc3RhdHVzIH0pIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXR1cyh7IHN0YXR1cyB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0dXMnLCB7IHN0YXR1cyB9KTtcbiAgICB9XG4gICAgc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uID0ge30pIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyICYmIGNvbmZpZ3VyYXRpb24udXJsKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWJzb2NrZXRQcm92aWRlckNvbmZpZyA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIgPSBuZXcgSG9jdXNwb2N1c1Byb3ZpZGVyV2Vic29ja2V0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHdlYnNvY2tldFByb3ZpZGVyQ29uZmlnLnVybCxcbiAgICAgICAgICAgICAgICBjb25uZWN0OiB3ZWJzb2NrZXRQcm92aWRlckNvbmZpZy5jb25uZWN0LFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHdlYnNvY2tldFByb3ZpZGVyQ29uZmlnLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7IC4uLnRoaXMuY29uZmlndXJhdGlvbiwgLi4uY29uZmlndXJhdGlvbiB9O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZG9jdW1lbnQ7XG4gICAgfVxuICAgIGdldCBhd2FyZW5lc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYXdhcmVuZXNzO1xuICAgIH1cbiAgICBnZXQgaGFzVW5zeW5jZWRDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnN5bmNlZENoYW5nZXMgPiAwO1xuICAgIH1cbiAgICBpbmNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzICs9IDE7XG4gICAgICAgIHRoaXMuZW1pdCgndW5zeW5jZWRDaGFuZ2VzJywgdGhpcy51bnN5bmNlZENoYW5nZXMpO1xuICAgIH1cbiAgICBkZWNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzIC09IDE7XG4gICAgICAgIGlmICh0aGlzLnVuc3luY2VkQ2hhbmdlcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndW5zeW5jZWRDaGFuZ2VzJywgdGhpcy51bnN5bmNlZENoYW5nZXMpO1xuICAgIH1cbiAgICBmb3JjZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuc2VuZChTeW5jU3RlcE9uZU1lc3NhZ2UsIHsgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgfVxuICAgIHBhZ2VVbmxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmF3YXJlbmVzcykge1xuICAgICAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2N1bWVudC5jbGllbnRJRF0sICd3aW5kb3cgdW5sb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgdGhpcy5ib3VuZFBhZ2VVbmxvYWQpO1xuICAgIH1cbiAgICBzZW5kU3RhdGVsZXNzKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5zZW5kKFN0YXRlbGVzc01lc3NhZ2UsIHsgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSwgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgZG9jdW1lbnRVcGRhdGVIYW5kbGVyKHVwZGF0ZSwgb3JpZ2luKSB7XG4gICAgICAgIGlmIChvcmlnaW4gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLnNlbmQoVXBkYXRlTWVzc2FnZSwgeyB1cGRhdGUsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZENsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpO1xuICAgICAgICB0aGlzLnNlbmQoQXdhcmVuZXNzTWVzc2FnZSwge1xuICAgICAgICAgICAgYXdhcmVuZXNzOiB0aGlzLmF3YXJlbmVzcyxcbiAgICAgICAgICAgIGNsaWVudHM6IGNoYW5nZWRDbGllbnRzLFxuICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgZmlyc3QgaGFuZHNoYWtlIHdpdGggdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCBtZWFuIGFsbCB1cGRhdGVzIGZyb20gdGhlIGNsaWVudCBoYXZlIGJlZW4gcGVyc2lzdGVkIHRvIHRoZSBiYWNrZW5kLiBGb3IgdGhpcyxcbiAgICAgKiB1c2UgYGhhc1Vuc3luY2VkQ2hhbmdlc2AuXG4gICAgICovXG4gICAgZ2V0IHN5bmNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTeW5jZWQ7XG4gICAgfVxuICAgIHNldCBzeW5jZWQoc3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTeW5jZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N5bmNlZCA9IHN0YXRlO1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIHsgc3RhdGUgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3luYycsIHsgc3RhdGUgfSk7XG4gICAgfVxuICAgIHJlY2VpdmVTdGF0ZWxlc3MocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YXRlbGVzcycsIHsgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgZ2V0IGlzQXV0aGVudGljYXRpb25SZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb25maWd1cmF0aW9uLnRva2VuICYmICF0aGlzLmlzQXV0aGVudGljYXRlZDtcbiAgICB9XG4gICAgLy8gbm90IG5lZWRlZCwgYnV0IHByb3ZpZGVzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBlLmcuIGxleGljbGEveWpzXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5icm9hZGNhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Ccm9hZGNhc3RDaGFubmVsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLnNob3VsZENvbm5lY3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmF0dGFjaCh0aGlzKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QnJvYWRjYXN0Q2hhbm5lbCgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuZGV0YWNoKHRoaXMpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jb25maWd1cmF0aW9uLnByZXNlcnZlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbk9wZW4oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicsIHsgZXZlbnQgfSk7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgdGhpcy5nZXRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uRGVuaWVkSGFuZGxlcihgRmFpbGVkIHRvIGdldCB0b2tlbjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChBdXRoZW50aWNhdGlvbk1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFN5bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW4oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWd1cmF0aW9uLnRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuY29uZmlndXJhdGlvbi50b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udG9rZW47XG4gICAgfVxuICAgIHN0YXJ0U3luYygpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5zZW5kKFN5bmNTdGVwT25lTWVzc2FnZSwgeyBkb2N1bWVudDogdGhpcy5kb2N1bWVudCwgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzICYmIHRoaXMuYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKEF3YXJlbmVzc01lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBhd2FyZW5lc3M6IHRoaXMuYXdhcmVuZXNzLFxuICAgICAgICAgICAgICAgIGNsaWVudHM6IFt0aGlzLmRvY3VtZW50LmNsaWVudElEXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZChtZXNzYWdlLCBhcmdzLCBicm9hZGNhc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICB0aGlzLm11eCgoKSA9PiB7IHRoaXMuYnJvYWRjYXN0KG1lc3NhZ2UsIGFyZ3MpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlU2VuZGVyID0gbmV3IE1lc3NhZ2VTZW5kZXIobWVzc2FnZSwgYXJncyk7XG4gICAgICAgIHRoaXMuZW1pdCgnb3V0Z29pbmdNZXNzYWdlJywgeyBtZXNzYWdlOiBtZXNzYWdlU2VuZGVyLm1lc3NhZ2UgfSk7XG4gICAgICAgIG1lc3NhZ2VTZW5kZXIuc2VuZCh0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIpO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50TmFtZSA9IG1lc3NhZ2UucmVhZFZhclN0cmluZygpO1xuICAgICAgICBtZXNzYWdlLndyaXRlVmFyU3RyaW5nKGRvY3VtZW50TmFtZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHsgZXZlbnQsIG1lc3NhZ2U6IG5ldyBJbmNvbWluZ01lc3NhZ2UoZXZlbnQuZGF0YSkgfSk7XG4gICAgICAgIG5ldyBNZXNzYWdlUmVjZWl2ZXIobWVzc2FnZSkuYXBwbHkodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIG9uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gdXBkYXRlIGF3YXJlbmVzcyAoYWxsIHVzZXJzIGV4Y2VwdCBsb2NhbCBsZWZ0KVxuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgQXJyYXkuZnJvbSh0aGlzLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpLmZpbHRlcihjbGllbnQgPT4gY2xpZW50ICE9PSB0aGlzLmRvY3VtZW50LmNsaWVudElEKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFscy5mb3JjZVN5bmMpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbHMuZm9yY2VTeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jdW1lbnQuY2xpZW50SURdLCAncHJvdmlkZXIgZGVzdHJveScpO1xuICAgICAgICAgICAgdGhpcy5hd2FyZW5lc3Mub2ZmKCd1cGRhdGUnLCB0aGlzLmF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5hd2FyZW5lc3MuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jdW1lbnQub2ZmKCd1cGRhdGUnLCB0aGlzLmRvY3VtZW50VXBkYXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignY29ubmVjdCcsIHRoaXMuZm9yd2FyZENvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdvcGVuJywgdGhpcy5ib3VuZE9uT3Blbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ29wZW4nLCB0aGlzLmZvcndhcmRPcGVuKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignY2xvc2UnLCB0aGlzLmJvdW5kT25DbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Nsb3NlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdjbG9zZScsIHRoaXMuZm9yd2FyZENsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignc3RhdHVzJywgdGhpcy5ib3VuZE9uU3RhdHVzKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignZGlzY29ubmVjdCcsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5mb3J3YXJkRGlzY29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignZGVzdHJveScsIHRoaXMuZm9yd2FyZERlc3Ryb3kpO1xuICAgICAgICB0aGlzLnNlbmQoQ2xvc2VNZXNzYWdlLCB7IGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgISgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmxvYWQnLCB0aGlzLmJvdW5kUGFnZVVubG9hZCk7XG4gICAgfVxuICAgIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKHJlYXNvbikge1xuICAgICAgICB0aGlzLmVtaXQoJ2F1dGhlbnRpY2F0aW9uRmFpbGVkJywgeyByZWFzb24gfSk7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQ7XG4gICAgfVxuICAgIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemVkU2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5lbWl0KCdhdXRoZW50aWNhdGVkJyk7XG4gICAgfVxuICAgIGdldCBicm9hZGNhc3RDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25maWd1cmF0aW9uLm5hbWV9YDtcbiAgICB9XG4gICAgYnJvYWRjYXN0Q2hhbm5lbFN1YnNjcmliZXIoZGF0YSkge1xuICAgICAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IEluY29taW5nTWVzc2FnZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50TmFtZSA9IG1lc3NhZ2UucmVhZFZhclN0cmluZygpO1xuICAgICAgICAgICAgbWVzc2FnZS53cml0ZVZhclN0cmluZyhkb2N1bWVudE5hbWUpO1xuICAgICAgICAgICAgbmV3IE1lc3NhZ2VSZWNlaXZlcihtZXNzYWdlKVxuICAgICAgICAgICAgICAgIC5zZXRCcm9hZGNhc3RlZCh0cnVlKVxuICAgICAgICAgICAgICAgIC5hcHBseSh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0Jyb2FkY2FzdENoYW5uZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVkVG9Ccm9hZGNhc3RDaGFubmVsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5icm9hZGNhc3RDaGFubmVsLCB0aGlzLmJvdW5kQnJvYWRjYXN0Q2hhbm5lbFN1YnNjcmliZXIpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkVG9Ccm9hZGNhc3RDaGFubmVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChTeW5jU3RlcE9uZU1lc3NhZ2UsIHsgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChTeW5jU3RlcFR3b01lc3NhZ2UsIHsgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChRdWVyeUF3YXJlbmVzc01lc3NhZ2UsIHsgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChBd2FyZW5lc3NNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgIGF3YXJlbmVzczogdGhpcy5hd2FyZW5lc3MsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudHM6IFt0aGlzLmRvY3VtZW50LmNsaWVudElEXSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0QnJvYWRjYXN0Q2hhbm5lbCgpIHtcbiAgICAgICAgLy8gYnJvYWRjYXN0IG1lc3NhZ2Ugd2l0aCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGUgc2V0IHRvIG51bGwgKGluZGljYXRpbmcgZGlzY29ubmVjdClcbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoQXdhcmVuZXNzTWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGF3YXJlbmVzczogdGhpcy5hd2FyZW5lc3MsXG4gICAgICAgICAgICAgICAgY2xpZW50czogW3RoaXMuZG9jdW1lbnQuY2xpZW50SURdLFxuICAgICAgICAgICAgICAgIHN0YXRlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkVG9Ccm9hZGNhc3RDaGFubmVsKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSh0aGlzLmJyb2FkY2FzdENoYW5uZWwsIHRoaXMuYm91bmRCcm9hZGNhc3RDaGFubmVsU3Vic2NyaWJlcik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZWRUb0Jyb2FkY2FzdENoYW5uZWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicm9hZGNhc3QoTWVzc2FnZSwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlndXJhdGlvbi5icm9hZGNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZFRvQnJvYWRjYXN0Q2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBNZXNzYWdlU2VuZGVyKE1lc3NhZ2UsIGFyZ3MpLmJyb2FkY2FzdCh0aGlzLmJyb2FkY2FzdENoYW5uZWwpO1xuICAgIH1cbiAgICBzZXRBd2FyZW5lc3NGaWVsZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBd2FyZW5lc3NFcnJvcihgQ2Fubm90IHNldCBhd2FyZW5lc3MgZmllbGQgXCIke2tleX1cIiB0byAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uIFlvdSBoYXZlIGRpc2FibGVkIEF3YXJlbmVzcyBmb3IgdGhpcyBwcm92aWRlciBieSBleHBsaWNpdGx5IHBhc3NpbmcgYXdhcmVuZXNzOiBudWxsIGluIHRoZSBwcm92aWRlciBjb25maWd1cmF0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChrZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuY29uc3QgZ2V0UmFuZG9tVmFsdWVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG5cbi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuY29uc3QgdWludDMyID0gKCkgPT4gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHV1aWR2NFRlbXBsYXRlID0gWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHV1aWR2NCA9ICgpID0+IHV1aWR2NFRlbXBsYXRlLnJlcGxhY2UoL1swMThdL2csIC8qKiBAcGFyYW0ge251bWJlcn0gYyAqLyBjID0+XG4gIChjIF4gdWludDMyKCkgJiAxNSA+PiBjIC8gNCkudG9TdHJpbmcoMTYpXG4pO1xuXG5jbGFzcyBUaXB0YXBDb2xsYWJQcm92aWRlcldlYnNvY2tldCBleHRlbmRzIEhvY3VzcG9jdXNQcm92aWRlcldlYnNvY2tldCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHsgLi4uY29uZmlndXJhdGlvbiwgdXJsOiAoX2EgPSBjb25maWd1cmF0aW9uLmJhc2VVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGB3c3M6Ly8ke2NvbmZpZ3VyYXRpb24uYXBwSWR9LmNvbGxhYi50aXB0YXAuY2xvdWRgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgVGlwdGFwQ29sbGFiUHJvdmlkZXIgZXh0ZW5kcyBIb2N1c3BvY3VzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyID0gbmV3IFRpcHRhcENvbGxhYlByb3ZpZGVyV2Vic29ja2V0KHsgYXBwSWQ6IGNvbmZpZ3VyYXRpb24uYXBwSWQsIGJhc2VVcmw6IGNvbmZpZ3VyYXRpb24uYmFzZVVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24udG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24udG9rZW4gPSAnbm90b2tlbic7IC8vIG5lZWQgdG8gc2VuZCBhIHRva2VuIGFueXdheSAod2hpY2ggd2lsbCBiZSBpZ25vcmVkKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLnRpcHRhcENvbGxhYkNvbmZpZ3VyYXRpb25QcmVmaXggPSAnX190aXB0YXBjb2xsYWJfXyc7XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLnVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRhdGEgPSBuZXcgWS5QZXJtYW5lbnRVc2VyRGF0YSh0aGlzLmRvY3VtZW50LCB0aGlzLmRvY3VtZW50LmdldE1hcCgnX190aXB0YXBjb2xsYWJfX3VzZXJzJykpO1xuICAgICAgICAgICAgdGhpcy51c2VyRGF0YS5zZXRVc2VyTWFwcGluZyh0aGlzLmRvY3VtZW50LCB0aGlzLmRvY3VtZW50LmNsaWVudElELCBjb25maWd1cmF0aW9uLnVzZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG5vdGU6IHRoaXMgd2lsbCBvbmx5IHdvcmsgaWYgeW91ciBzZXJ2ZXIgbG9hZGVkIEBob2N1c3BvY3VzLXByby9leHRlbnNpb24taGlzdG9yeSwgb3IgaWYgeW91IGFyZSBvbiBhIFRpcHRhcCBidXNpbmVzcyBwbGFuLlxuICAgICAqL1xuICAgIGNyZWF0ZVZlcnNpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kU3RhdGVsZXNzKEpTT04uc3RyaW5naWZ5KHsgYWN0aW9uOiAndmVyc2lvbi5jcmVhdGUnLCBuYW1lIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbm90ZTogdGhpcyB3aWxsIG9ubHkgd29yayBpZiB5b3VyIHNlcnZlciBsb2FkZWQgQGhvY3VzcG9jdXMtcHJvL2V4dGVuc2lvbi1oaXN0b3J5LCBvciBpZiB5b3UgYXJlIG9uIGEgVGlwdGFwIGJ1c2luZXNzIHBsYW4uXG4gICAgICovXG4gICAgcmV2ZXJ0VG9WZXJzaW9uKHRhcmdldFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFN0YXRlbGVzcyhKU09OLnN0cmluZ2lmeSh7IGFjdGlvbjogJ2RvY3VtZW50LnJldmVydCcsIHZlcnNpb246IHRhcmdldFZlcnNpb24gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBub3RlOiB0aGlzIHdpbGwgb25seSB3b3JrIGlmIHlvdXIgc2VydmVyIGxvYWRlZCBAaG9jdXNwb2N1cy1wcm8vZXh0ZW5zaW9uLWhpc3RvcnksIG9yIGlmIHlvdSBhcmUgb24gYSBUaXB0YXAgYnVzaW5lc3MgcGxhbi5cbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgd2lsbCByZXBseSB3aXRoIGEgc3RhdGVsZXNzIG1lc3NhZ2UgKFRIaXN0b3J5VmVyc2lvblByZXZpZXdFdmVudClcbiAgICAgKi9cbiAgICBwcmV2aWV3VmVyc2lvbih0YXJnZXRWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRTdGF0ZWxlc3MoSlNPTi5zdHJpbmdpZnkoeyBhY3Rpb246ICd2ZXJzaW9uLnByZXZpZXcnLCB2ZXJzaW9uOiB0YXJnZXRWZXJzaW9uIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbm90ZTogdGhpcyB3aWxsIG9ubHkgd29yayBpZiB5b3VyIHNlcnZlciBsb2FkZWQgQGhvY3VzcG9jdXMtcHJvL2V4dGVuc2lvbi1oaXN0b3J5LCBvciBpZiB5b3UgYXJlIG9uIGEgVGlwdGFwIGJ1c2luZXNzIHBsYW4uXG4gICAgICovXG4gICAgZ2V0VmVyc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZG9jdW1lbnQuZ2V0QXJyYXkoYCR7dGhpcy50aXB0YXBDb2xsYWJDb25maWd1cmF0aW9uUHJlZml4fXZlcnNpb25zYCkudG9BcnJheSgpO1xuICAgIH1cbiAgICB3YXRjaFZlcnNpb25zKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZG9jdW1lbnQuZ2V0QXJyYXkoJ19fdGlwdGFwY29sbGFiX192ZXJzaW9ucycpLm9ic2VydmUoY2FsbGJhY2spO1xuICAgIH1cbiAgICB1bndhdGNoVmVyc2lvbnMoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5kb2N1bWVudC5nZXRBcnJheSgnX190aXB0YXBjb2xsYWJfX3ZlcnNpb25zJykudW5vYnNlcnZlKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaXNBdXRvVmVyc2lvbmluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb25maWd1cmF0aW9uLmRvY3VtZW50LmdldE1hcChgJHt0aGlzLnRpcHRhcENvbGxhYkNvbmZpZ3VyYXRpb25QcmVmaXh9Y29uZmlnYCkuZ2V0KCdhdXRvVmVyc2lvbmluZycpO1xuICAgIH1cbiAgICBlbmFibGVBdXRvVmVyc2lvbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5kb2N1bWVudC5nZXRNYXAoYCR7dGhpcy50aXB0YXBDb2xsYWJDb25maWd1cmF0aW9uUHJlZml4fWNvbmZpZ2ApLnNldCgnYXV0b1ZlcnNpb25pbmcnLCAxKTtcbiAgICB9XG4gICAgZGlzYWJsZUF1dG9WZXJzaW9uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmRvY3VtZW50LmdldE1hcChgJHt0aGlzLnRpcHRhcENvbGxhYkNvbmZpZ3VyYXRpb25QcmVmaXh9Y29uZmlnYCkuc2V0KCdhdXRvVmVyc2lvbmluZycsIDApO1xuICAgIH1cbiAgICBnZXRZVGhyZWFkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5kb2N1bWVudC5nZXRBcnJheShgJHt0aGlzLnRpcHRhcENvbGxhYkNvbmZpZ3VyYXRpb25QcmVmaXh9dGhyZWFkc2ApO1xuICAgIH1cbiAgICBnZXRUaHJlYWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRZVGhyZWFkcygpLnRvSlNPTigpO1xuICAgIH1cbiAgICBnZXRUaHJlYWRJbmRleChpZCkge1xuICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiB0aGlzLmdldFRocmVhZHMoKSkge1xuICAgICAgICAgICAgaWYgKHRocmVhZC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBnZXRUaHJlYWQoaWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFRocmVhZEluZGV4KGlkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRZVGhyZWFkcygpLmdldChpbmRleCkudG9KU09OKCk7XG4gICAgfVxuICAgIGdldFlUaHJlYWQoaWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFRocmVhZEluZGV4KGlkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRZVGhyZWFkcygpLmdldChpbmRleCk7XG4gICAgfVxuICAgIGNyZWF0ZVRocmVhZChkYXRhKSB7XG4gICAgICAgIGxldCBjcmVhdGVkVGhyZWFkID0ge307XG4gICAgICAgIHRoaXMuZG9jdW1lbnQudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGhyZWFkID0gbmV3IFkuTWFwKCk7XG4gICAgICAgICAgICB0aHJlYWQuc2V0KCdpZCcsIHV1aWR2NCgpKTtcbiAgICAgICAgICAgIHRocmVhZC5zZXQoJ2NyZWF0ZWRBdCcsIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgIHRocmVhZC5zZXQoJ2NvbW1lbnRzJywgbmV3IFkuQXJyYXkoKSk7XG4gICAgICAgICAgICB0aGlzLmdldFlUaHJlYWRzKCkucHVzaChbdGhyZWFkXSk7XG4gICAgICAgICAgICBjcmVhdGVkVGhyZWFkID0gdGhpcy51cGRhdGVUaHJlYWQoU3RyaW5nKHRocmVhZC5nZXQoJ2lkJykpLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVkVGhyZWFkO1xuICAgIH1cbiAgICB1cGRhdGVUaHJlYWQoaWQsIGRhdGEpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRUaHJlYWQgPSB7fTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aHJlYWQgPSB0aGlzLmdldFlUaHJlYWQoaWQpO1xuICAgICAgICAgICAgaWYgKHRocmVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyZWFkLnNldCgndXBkYXRlZEF0JywgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocmVhZC5zZXQoJ2RhdGEnLCBkYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEucmVzb2x2ZWRBdCB8fCBkYXRhLnJlc29sdmVkQXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJlYWQuc2V0KCdyZXNvbHZlZEF0JywgZGF0YS5yZXNvbHZlZEF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRUaHJlYWQgPSB0aHJlYWQudG9KU09OKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgICB9XG4gICAgZGVsZXRlVGhyZWFkKGlkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRUaHJlYWRJbmRleChpZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0WVRocmVhZHMoKS5kZWxldGUoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBnZXRUaHJlYWRDb21tZW50cyh0aHJlYWRJZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0VGhyZWFkSW5kZXgodGhyZWFkSWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmdldFRocmVhZCh0aHJlYWRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21tZW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgfVxuICAgIGdldFRocmVhZENvbW1lbnQodGhyZWFkSWQsIGNvbW1lbnRJZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0VGhyZWFkSW5kZXgodGhyZWFkSWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmdldFRocmVhZCh0aHJlYWRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21tZW50cy5maW5kKGNvbW1lbnQgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICB9XG4gICAgYWRkQ29tbWVudCh0aHJlYWRJZCwgZGF0YSkge1xuICAgICAgICBsZXQgdXBkYXRlZFRocmVhZCA9IHt9O1xuICAgICAgICB0aGlzLmRvY3VtZW50LnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRocmVhZCA9IHRoaXMuZ2V0WVRocmVhZCh0aHJlYWRJZCk7XG4gICAgICAgICAgICBpZiAodGhyZWFkID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgY29tbWVudE1hcCA9IG5ldyBZLk1hcCgpO1xuICAgICAgICAgICAgY29tbWVudE1hcC5zZXQoJ2lkJywgdXVpZHY0KCkpO1xuICAgICAgICAgICAgY29tbWVudE1hcC5zZXQoJ2NyZWF0ZWRBdCcsIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgIHRocmVhZC5nZXQoJ2NvbW1lbnRzJykucHVzaChbY29tbWVudE1hcF0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb21tZW50KHRocmVhZElkLCBTdHJpbmcoY29tbWVudE1hcC5nZXQoJ2lkJykpLCBkYXRhKTtcbiAgICAgICAgICAgIHVwZGF0ZWRUaHJlYWQgPSB0aHJlYWQudG9KU09OKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgICB9XG4gICAgdXBkYXRlQ29tbWVudCh0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhKSB7XG4gICAgICAgIGxldCB1cGRhdGVkVGhyZWFkID0ge307XG4gICAgICAgIHRoaXMuZG9jdW1lbnQudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGhyZWFkID0gdGhpcy5nZXRZVGhyZWFkKHRocmVhZElkKTtcbiAgICAgICAgICAgIGlmICh0aHJlYWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiB0aHJlYWQuZ2V0KCdjb21tZW50cycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZ2V0KCdpZCcpID09PSBjb21tZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29tbWVudC5zZXQoJ3VwZGF0ZWRBdCcsIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LnNldCgnZGF0YScsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudC5zZXQoJ2NvbnRlbnQnLCBkYXRhLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZFRocmVhZCA9IHRocmVhZC50b0pTT04oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICAgIH1cbiAgICBkZWxldGVDb21tZW50KHRocmVhZElkLCBjb21tZW50SWQpIHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhpcy5nZXRZVGhyZWFkKHRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgY29tbWVudEluZGV4ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aHJlYWQuZ2V0KCdjb21tZW50cycpKSB7XG4gICAgICAgICAgICBpZiAoYy5nZXQoJ2lkJykgPT09IGNvbW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tbWVudEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGNvbW1lbnQgb2YgYSB0aHJlYWQgaXMgZGVsZXRlZCB3ZSBhbHNvXG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgdGhyZWFkIGl0c2VsZiBhcyB0aGUgc291cmNlIGNvbW1lbnQgaXMgZ29uZVxuICAgICAgICBpZiAoY29tbWVudEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVRocmVhZCh0aHJlYWRJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRocmVhZC5nZXQoJ2NvbW1lbnRzJykuZGVsZXRlKGNvbW1lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRocmVhZC50b0pTT04oKTtcbiAgICB9XG4gICAgd2F0Y2hUaHJlYWRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2V0WVRocmVhZHMoKS5vYnNlcnZlRGVlcChjYWxsYmFjayk7XG4gICAgfVxuICAgIHVud2F0Y2hUaHJlYWRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2V0WVRocmVhZHMoKS51bm9ic2VydmVEZWVwKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEF3YXJlbmVzc0Vycm9yLCBIb2N1c3BvY3VzUHJvdmlkZXIsIEhvY3VzcG9jdXNQcm92aWRlcldlYnNvY2tldCwgTWVzc2FnZVR5cGUsIFRpcHRhcENvbGxhYlByb3ZpZGVyLCBUaXB0YXBDb2xsYWJQcm92aWRlcldlYnNvY2tldCwgV2ViU29ja2V0U3RhdHVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\n");

/***/ })

};
;